var Plugin = (function (exports, singleclick, map) {
	'use strict';

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	/** True if experimental.async=true */
	/** True if we're not certain that we only have Svelte 5 code in the compilation */
	let legacy_mode_flag = false;
	/** True if $inspect.trace is used */
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	enable_legacy_mode_flag();

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	var DEV = false;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * TODO replace with Promise.withResolvers once supported widely enough
	 * @template [T=void]
	 */
	function deferred() {
		/** @type {(value: T) => void} */
		var resolve;

		/** @type {(reason: any) => void} */
		var reject;

		/** @type {Promise<T>} */
		var promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});

		// @ts-expect-error
		return { promise, resolve, reject };
	}

	// General flags
	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	/**
	 * An effect that does not destroy its child effects when it reruns.
	 * Runs as part of render effects, i.e. not eagerly as part of tree traversal or effect flushing.
	 */
	const MANAGED_EFFECT = 1 << 24;
	/**
	 * An effect that does not destroy its child effects when it reruns (like MANAGED_EFFECT).
	 * Runs eagerly as part of tree traversal or effect flushing.
	 */
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	/**
	 * Indicates that a reaction is connected to an effect root — either it is an effect,
	 * or it is a derived that is depended on by at least one effect. If a derived has
	 * no dependents, we can disconnect it from the graph, allowing it to either be
	 * GC'd or reconnected later if an effect comes to depend on it again
	 */
	const CONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;

	// Flags exclusive to effects
	/** Set once an effect that should run synchronously has run */
	const EFFECT_RAN = 1 << 15;
	/**
	 * 'Transparent' effects do not create a transition boundary.
	 * This is on a block effect 99% of the time but may also be on a branch effect if its parent block effect was pruned
	 */
	const EFFECT_TRANSPARENT = 1 << 16;
	const EAGER_EFFECT = 1 << 17;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_PRESERVED = 1 << 19;
	const USER_EFFECT = 1 << 20;
	const EFFECT_OFFSCREEN = 1 << 25;

	// Flags exclusive to deriveds
	/**
	 * Tells that we marked this derived and its reactions as visited during the "mark as (maybe) dirty"-phase.
	 * Will be lifted during execution of the derived and during checking its dirty state (both are necessary
	 * because a derived might be checked but not executed).
	 */
	const WAS_MARKED = 1 << 15;

	// Flags used for async
	const REACTION_IS_UPDATING = 1 << 21;
	const ASYNC = 1 << 22;

	const ERROR_VALUE = 1 << 23;

	const STATE_SYMBOL = Symbol('$state');

	/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
	const STALE_REACTION = new (class StaleReactionError extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Cannot create a `$derived(...)` with an `await` expression outside of an effect tree
	 * @returns {never}
	 */
	function async_derived_orphan() {
		{
			throw new Error(`https://svelte.dev/e/async_derived_orphan`);
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */

	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			i: false,
			c: null,
			e: null,
			s: props,
			x: null,
			l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
		};
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		var context = /** @type {ComponentContext} */ (component_context);
		var effects = context.e;

		if (effects !== null) {
			context.e = null;

			for (var fn of effects) {
				create_user_effect(fn);
			}
		}

		context.i = true;

		component_context = context.p;

		return /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0 && !is_flushing_sync) {
			var tasks = micro_tasks;
			queueMicrotask(() => {
				// If this is false, a flushSync happened in the meantime. Do _not_ run new scheduled microtasks in that case
				// as the ordering of microtasks would be broken at that point - consider this case:
				// - queue_micro_task schedules microtask A to flush task X
				// - synchronously after, flushSync runs, processing task X
				// - synchronously after, some other microtask B is scheduled, but not through queue_micro_task but for example a Promise.resolve() in user code
				// - synchronously after, queue_micro_task schedules microtask C to flush task Y
				// - one tick later, microtask A now resolves, flushing task Y before microtask B, which is incorrect
				// This if check prevents that race condition (that realistically will only happen in tests)
				if (tasks === micro_tasks) run_micro_tasks();
			});
		}

		micro_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		while (micro_tasks.length > 0) {
			run_micro_tasks();
		}
	}

	/** @import { Derived, Effect } from '#client' */
	/** @import { Boundary } from './dom/blocks/boundary.js' */

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = active_effect;

		// for unowned deriveds, don't throw until we read the value
		if (effect === null) {
			/** @type {Derived} */ (active_reaction).f |= ERROR_VALUE;
			return error;
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {

				throw error;
			}

			/** @type {Boundary} */ (effect.b).error(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					/** @type {Boundary} */ (effect.b).error(error);
					return;
				} catch (e) {
					error = e;
				}
			}

			effect = effect.parent;
		}

		throw error;
	}

	/** @import { Fork } from 'svelte' */
	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	/**
	 * @typedef {{
	 *   parent: EffectTarget | null;
	 *   effect: Effect | null;
	 *   effects: Effect[];
	 *   render_effects: Effect[];
	 *   block_effects: Effect[];
	 * }} EffectTarget
	 */

	/** @type {Set<Batch>} */
	const batches = new Set();

	/** @type {Batch | null} */
	let current_batch = null;

	/**
	 * This is needed to avoid overwriting inputs in non-async mode
	 * TODO 6.0 remove this, as non-async mode will go away
	 * @type {Batch | null}
	 */
	let previous_batch = null;

	/**
	 * When time travelling (i.e. working in one batch, while other batches
	 * still have ongoing work), we ignore the real values of affected
	 * signals in favour of their values within the batch
	 * @type {Map<Value, any> | null}
	 */
	let batch_values = null;

	// TODO this should really be a property of `batch`
	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing = false;
	let is_flushing_sync = false;

	class Batch {
		committed = false;

		/**
		 * The current values of any sources that are updated in this batch
		 * They keys of this map are identical to `this.#previous`
		 * @type {Map<Source, any>}
		 */
		current = new Map();

		/**
		 * The values of any sources that are updated in this batch _before_ those updates took place.
		 * They keys of this map are identical to `this.#current`
		 * @type {Map<Source, any>}
		 */
		previous = new Map();

		/**
		 * When the batch is committed (and the DOM is updated), we need to remove old branches
		 * and append new ones by calling the functions added inside (if/each/key/etc) blocks
		 * @type {Set<() => void>}
		 */
		#commit_callbacks = new Set();

		/**
		 * If a fork is discarded, we need to destroy any effects that are no longer needed
		 * @type {Set<(batch: Batch) => void>}
		 */
		#discard_callbacks = new Set();

		/**
		 * The number of async effects that are currently in flight
		 */
		#pending = 0;

		/**
		 * The number of async effects that are currently in flight, _not_ inside a pending boundary
		 */
		#blocking_pending = 0;

		/**
		 * A deferred that resolves when the batch is committed, used with `settled()`
		 * TODO replace with Promise.withResolvers once supported widely enough
		 * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
		 */
		#deferred = null;

		/**
		 * Deferred effects (which run after async work has completed) that are DIRTY
		 * @type {Effect[]}
		 */
		#dirty_effects = [];

		/**
		 * Deferred effects that are MAYBE_DIRTY
		 * @type {Effect[]}
		 */
		#maybe_dirty_effects = [];

		/**
		 * A set of branches that still exist, but will be destroyed when this batch
		 * is committed — we skip over these during `process`
		 * @type {Set<Effect>}
		 */
		skipped_effects = new Set();

		is_fork = false;

		is_deferred() {
			return this.is_fork || this.#blocking_pending > 0;
		}

		/**
		 *
		 * @param {Effect[]} root_effects
		 */
		process(root_effects) {
			queued_root_effects = [];

			previous_batch = null;

			this.apply();

			/** @type {EffectTarget} */
			var target = {
				parent: null,
				effect: null,
				effects: [],
				render_effects: [],
				block_effects: []
			};

			for (const root of root_effects) {
				this.#traverse_effect_tree(root, target);
				// Note: #traverse_effect_tree runs block effects eagerly, which can schedule effects,
				// which means queued_root_effects now may be filled again.

				// Helpful for debugging reactivity loss that has to do with branches being skipped:
				// log_inconsistent_branches(root);
			}

			if (!this.is_fork) {
				this.#resolve();
			}

			if (this.is_deferred()) {
				this.#defer_effects(target.effects);
				this.#defer_effects(target.render_effects);
				this.#defer_effects(target.block_effects);
			} else {
				// If sources are written to, then work needs to happen in a separate batch, else prior sources would be mixed with
				// newly updated sources, which could lead to infinite loops when effects run over and over again.
				previous_batch = this;
				current_batch = null;

				flush_queued_effects(target.render_effects);
				flush_queued_effects(target.effects);

				previous_batch = null;

				this.#deferred?.resolve();
			}

			batch_values = null;
		}

		/**
		 * Traverse the effect tree, executing effects or stashing
		 * them for later execution as appropriate
		 * @param {Effect} root
		 * @param {EffectTarget} target
		 */
		#traverse_effect_tree(root, target) {
			root.f ^= CLEAN;

			var effect = root.first;

			while (effect !== null) {
				var flags = effect.f;
				var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
				var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

				var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);

				if ((effect.f & BOUNDARY_EFFECT) !== 0 && effect.b?.is_pending()) {
					target = {
						parent: target,
						effect,
						effects: [],
						render_effects: [],
						block_effects: []
					};
				}

				if (!skip && effect.fn !== null) {
					if (is_branch) {
						effect.f ^= CLEAN;
					} else if ((flags & EFFECT) !== 0) {
						target.effects.push(effect);
					} else if (is_dirty(effect)) {
						if ((effect.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect);
						update_effect(effect);
					}

					var child = effect.first;

					if (child !== null) {
						effect = child;
						continue;
					}
				}

				var parent = effect.parent;
				effect = effect.next;

				while (effect === null && parent !== null) {
					if (parent === target.effect) {
						// TODO rather than traversing into pending boundaries and deferring the effects,
						// could we just attach the effects _to_ the pending boundary and schedule them
						// once the boundary is ready?
						this.#defer_effects(target.effects);
						this.#defer_effects(target.render_effects);
						this.#defer_effects(target.block_effects);

						target = /** @type {EffectTarget} */ (target.parent);
					}

					effect = parent.next;
					parent = parent.parent;
				}
			}
		}

		/**
		 * @param {Effect[]} effects
		 */
		#defer_effects(effects) {
			for (const e of effects) {
				const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
				target.push(e);

				// Since we're not executing these effects now, we need to clear any WAS_MARKED flags
				// so that other batches can correctly reach these effects during their own traversal
				this.#clear_marked(e.deps);

				// mark as clean so they get scheduled if they depend on pending async state
				set_signal_status(e, CLEAN);
			}
		}

		/**
		 * @param {Value[] | null} deps
		 */
		#clear_marked(deps) {
			if (deps === null) return;

			for (const dep of deps) {
				if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
					continue;
				}

				dep.f ^= WAS_MARKED;

				this.#clear_marked(/** @type {Derived} */ (dep).deps);
			}
		}

		/**
		 * Associate a change to a given source with the current
		 * batch, noting its previous and current values
		 * @param {Source} source
		 * @param {any} value
		 */
		capture(source, value) {
			if (!this.previous.has(source)) {
				this.previous.set(source, value);
			}

			// Don't save errors in `batch_values`, or they won't be thrown in `runtime.js#get`
			if ((source.f & ERROR_VALUE) === 0) {
				this.current.set(source, source.v);
				batch_values?.set(source, source.v);
			}
		}

		activate() {
			current_batch = this;
			this.apply();
		}

		deactivate() {
			// If we're not the current batch, don't deactivate,
			// else we could create zombie batches that are never flushed
			if (current_batch !== this) return;

			current_batch = null;
			batch_values = null;
		}

		flush() {
			this.activate();

			if (queued_root_effects.length > 0) {
				flush_effects();

				if (current_batch !== null && current_batch !== this) {
					// this can happen if a new batch was created during `flush_effects()`
					return;
				}
			} else if (this.#pending === 0) {
				this.process([]); // TODO this feels awkward
			}

			this.deactivate();
		}

		discard() {
			for (const fn of this.#discard_callbacks) fn(this);
			this.#discard_callbacks.clear();
		}

		#resolve() {
			if (this.#blocking_pending === 0) {
				// append/remove branches
				for (const fn of this.#commit_callbacks) fn();
				this.#commit_callbacks.clear();
			}

			if (this.#pending === 0) {
				this.#commit();
			}
		}

		#commit() {
			// If there are other pending batches, they now need to be 'rebased' —
			// in other words, we re-run block/async effects with the newly
			// committed state, unless the batch in question has a more
			// recent value for a given source
			if (batches.size > 1) {
				this.previous.clear();

				var previous_batch_values = batch_values;
				var is_earlier = true;

				/** @type {EffectTarget} */
				var dummy_target = {
					parent: null,
					effect: null,
					effects: [],
					render_effects: [],
					block_effects: []
				};

				for (const batch of batches) {
					if (batch === this) {
						is_earlier = false;
						continue;
					}

					/** @type {Source[]} */
					const sources = [];

					for (const [source, value] of this.current) {
						if (batch.current.has(source)) {
							if (is_earlier && value !== batch.current.get(source)) {
								// bring the value up to date
								batch.current.set(source, value);
							} else {
								// same value or later batch has more recent value,
								// no need to re-run these effects
								continue;
							}
						}

						sources.push(source);
					}

					if (sources.length === 0) {
						continue;
					}

					// Re-run async/block effects that depend on distinct values changed in both batches
					const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
					if (others.length > 0) {
						// Avoid running queued root effects on the wrong branch
						var prev_queued_root_effects = queued_root_effects;
						queued_root_effects = [];

						/** @type {Set<Value>} */
						const marked = new Set();
						/** @type {Map<Reaction, boolean>} */
						const checked = new Map();
						for (const source of sources) {
							mark_effects(source, others, marked, checked);
						}

						if (queued_root_effects.length > 0) {
							current_batch = batch;
							batch.apply();

							for (const root of queued_root_effects) {
								batch.#traverse_effect_tree(root, dummy_target);
							}

							// TODO do we need to do anything with `target`? defer block effects?

							batch.deactivate();
						}

						queued_root_effects = prev_queued_root_effects;
					}
				}

				current_batch = null;
				batch_values = previous_batch_values;
			}

			this.committed = true;
			batches.delete(this);
		}

		/**
		 *
		 * @param {boolean} blocking
		 */
		increment(blocking) {
			this.#pending += 1;
			if (blocking) this.#blocking_pending += 1;
		}

		/**
		 *
		 * @param {boolean} blocking
		 */
		decrement(blocking) {
			this.#pending -= 1;
			if (blocking) this.#blocking_pending -= 1;

			this.revive();
		}

		revive() {
			for (const e of this.#dirty_effects) {
				set_signal_status(e, DIRTY);
				schedule_effect(e);
			}

			for (const e of this.#maybe_dirty_effects) {
				set_signal_status(e, MAYBE_DIRTY);
				schedule_effect(e);
			}

			this.#dirty_effects = [];
			this.#maybe_dirty_effects = [];

			this.flush();
		}

		/** @param {() => void} fn */
		oncommit(fn) {
			this.#commit_callbacks.add(fn);
		}

		/** @param {(batch: Batch) => void} fn */
		ondiscard(fn) {
			this.#discard_callbacks.add(fn);
		}

		settled() {
			return (this.#deferred ??= deferred()).promise;
		}

		static ensure() {
			if (current_batch === null) {
				const batch = (current_batch = new Batch());
				batches.add(current_batch);

				if (!is_flushing_sync) {
					Batch.enqueue(() => {
						if (current_batch !== batch) {
							// a flushSync happened in the meantime
							return;
						}

						batch.flush();
					});
				}
			}

			return current_batch;
		}

		/** @param {() => void} task */
		static enqueue(task) {
			queue_micro_task(task);
		}

		apply() {
			return;
		}
	}

	/**
	 * Synchronously flush any pending updates.
	 * Returns void if no callback is provided, otherwise returns the result of calling the callback.
	 * @template [T=void]
	 * @param {(() => T) | undefined} [fn]
	 * @returns {T}
	 */
	function flushSync(fn) {
		var was_flushing_sync = is_flushing_sync;
		is_flushing_sync = true;

		try {
			var result;

			if (fn) ;

			while (true) {
				flush_tasks();

				if (queued_root_effects.length === 0) {
					current_batch?.flush();

					// we need to check again, in case we just updated an `$effect.pending()`
					if (queued_root_effects.length === 0) {
						// this would be reset in `flush_effects()` but since we are early returning here,
						// we need to reset it here as well in case the first time there's 0 queued root effects
						last_scheduled_effect = null;

						return /** @type {T} */ (result);
					}
				}

				flush_effects();
			}
		} finally {
			is_flushing_sync = was_flushing_sync;
		}
	}

	function flush_effects() {
		var was_updating_effect = is_updating_effect;
		is_flushing = true;

		var source_stacks = null;

		try {
			var flush_count = 0;
			set_is_updating_effect(true);

			while (queued_root_effects.length > 0) {
				var batch = Batch.ensure();

				if (flush_count++ > 1000) {
					var updates, entry; if (DEV) ;

					infinite_loop_guard();
				}

				batch.process(queued_root_effects);
				old_values.clear();

				if (DEV) ;
			}
		} finally {
			is_flushing = false;
			set_is_updating_effect(was_updating_effect);

			last_scheduled_effect = null;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {

			// Best effort: invoke the boundary nearest the most recent
			// effect and hope that it's relevant to the infinite loop
			invoke_error_boundary(error, last_scheduled_effect);
		}
	}

	/** @type {Set<Effect> | null} */
	let eager_block_effects = null;

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		var i = 0;

		while (i < length) {
			var effect = effects[i++];

			if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
				eager_block_effects = new Set();

				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes === null) {
					// if there's no teardown or abort controller we completely unlink
					// the effect from the graph
					if (effect.teardown === null && effect.ac === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}

				// If update_effect() has a flushSync() in it, we may have flushed another flush_queued_effects(),
				// which already handled this logic and did set eager_block_effects to null.
				if (eager_block_effects?.size > 0) {
					old_values.clear();

					for (const e of eager_block_effects) {
						// Skip eager effects that have already been unmounted
						if ((e.f & (DESTROYED | INERT)) !== 0) continue;

						// Run effects in order from ancestor to descendant, else we could run into nullpointers
						/** @type {Effect[]} */
						const ordered_effects = [e];
						let ancestor = e.parent;
						while (ancestor !== null) {
							if (eager_block_effects.has(ancestor)) {
								eager_block_effects.delete(ancestor);
								ordered_effects.push(ancestor);
							}
							ancestor = ancestor.parent;
						}

						for (let j = ordered_effects.length - 1; j >= 0; j--) {
							const e = ordered_effects[j];
							// Skip eager effects that have already been unmounted
							if ((e.f & (DESTROYED | INERT)) !== 0) continue;
							update_effect(e);
						}
					}

					eager_block_effects.clear();
				}
			}
		}

		eager_block_effects = null;
	}

	/**
	 * This is similar to `mark_reactions`, but it only marks async/block effects
	 * depending on `value` and at least one of the other `sources`, so that
	 * these effects can re-run after another batch has been committed
	 * @param {Value} value
	 * @param {Source[]} sources
	 * @param {Set<Value>} marked
	 * @param {Map<Reaction, boolean>} checked
	 */
	function mark_effects(value, sources, marked, checked) {
		if (marked.has(value)) return;
		marked.add(value);

		if (value.reactions !== null) {
			for (const reaction of value.reactions) {
				const flags = reaction.f;

				if ((flags & DERIVED) !== 0) {
					mark_effects(/** @type {Derived} */ (reaction), sources, marked, checked);
				} else if (
					(flags & (ASYNC | BLOCK_EFFECT)) !== 0 &&
					(flags & DIRTY) === 0 &&
					depends_on(reaction, sources, checked)
				) {
					set_signal_status(reaction, DIRTY);
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/**
	 * @param {Reaction} reaction
	 * @param {Source[]} sources
	 * @param {Map<Reaction, boolean>} checked
	 */
	function depends_on(reaction, sources, checked) {
		const depends = checked.get(reaction);
		if (depends !== undefined) return depends;

		if (reaction.deps !== null) {
			for (const dep of reaction.deps) {
				if (sources.includes(dep)) {
					return true;
				}

				if ((dep.f & DERIVED) !== 0 && depends_on(/** @type {Derived} */ (dep), sources, checked)) {
					checked.set(/** @type {Derived} */ (dep), true);
					return true;
				}
			}
		}

		checked.set(reaction, false);

		return false;
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			// if the effect is being scheduled because a parent (each/await/etc) block
			// updated an internal source, bail out or we'll cause a second flush
			if (
				is_flushing &&
				effect === active_effect &&
				(flags & BLOCK_EFFECT) !== 0 &&
				(flags & HEAD_EFFECT) === 0
			) {
				return;
			}

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/** @import { Effect, TemplateNode, Value } from '#client' */

	/**
	 * @param {Array<Promise<void>>} blockers
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {(values: Value[]) => any} fn
	 */
	function flatten(blockers, sync, async, fn) {
		const d = is_runes() ? derived : derived_safe_equal;

		if (async.length === 0 && blockers.length === 0) {
			fn(sync.map(d));
			return;
		}

		var batch = current_batch;
		var parent = /** @type {Effect} */ (active_effect);

		var restore = capture();

		function run() {
			Promise.all(async.map((expression) => async_derived(expression)))
				.then((result) => {
					restore();

					try {
						fn([...sync.map(d), ...result]);
					} catch (error) {
						// ignore errors in blocks that have already been destroyed
						if ((parent.f & DESTROYED) === 0) {
							invoke_error_boundary(error, parent);
						}
					}

					batch?.deactivate();
					unset_context();
				})
				.catch((error) => {
					invoke_error_boundary(error, parent);
				});
		}

		if (blockers.length > 0) {
			Promise.all(blockers).then(() => {
				restore();

				try {
					return run();
				} finally {
					batch?.deactivate();
					unset_context();
				}
			});
		} else {
			run();
		}
	}

	/**
	 * Captures the current effect context so that we can restore it after
	 * some asynchronous work has happened (so that e.g. `await a + b`
	 * causes `b` to be registered as a dependency).
	 */
	function capture() {
		var previous_effect = active_effect;
		var previous_reaction = active_reaction;
		var previous_component_context = component_context;
		var previous_batch = current_batch;

		return function restore(activate_batch = true) {
			set_active_effect(previous_effect);
			set_active_reaction(previous_reaction);
			set_component_context(previous_component_context);
			if (activate_batch) previous_batch?.activate();
		};
	}

	function unset_context() {
		set_active_effect(null);
		set_active_reaction(null);
		set_component_context(null);
	}

	/** @import { Derived, Effect, Source } from '#client' */
	/** @import { Batch } from './batch.js'; */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect !== null) {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_PRESERVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (UNINITIALIZED),
			wv: 0,
			parent: parent_derived ?? active_effect,
			ac: null
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V | Promise<V>} fn
	 * @param {string} [location] If provided, print a warning if the value is not read immediately after update
	 * @returns {Promise<Source<V>>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function async_derived(fn, location) {
		let parent = /** @type {Effect | null} */ (active_effect);

		if (parent === null) {
			async_derived_orphan();
		}

		var boundary = /** @type {Boundary} */ (parent.b);

		var promise = /** @type {Promise<V>} */ (/** @type {unknown} */ (undefined));
		var signal = source(/** @type {V} */ (UNINITIALIZED));

		// only suspend in async deriveds created on initialisation
		var should_suspend = !active_reaction;

		/** @type {Map<Batch, ReturnType<typeof deferred<V>>>} */
		var deferreds = new Map();

		async_effect(() => {

			/** @type {ReturnType<typeof deferred<V>>} */
			var d = deferred();
			promise = d.promise;

			try {
				// If this code is changed at some point, make sure to still access the then property
				// of fn() to read any signals it might access, so that we track them as dependencies.
				// We call `unset_context` to undo any `save` calls that happen inside `fn()`
				Promise.resolve(fn())
					.then(d.resolve, d.reject)
					.then(() => {
						if (batch === current_batch && batch.committed) {
							// if the batch was rejected as stale, we need to cleanup
							// after any `$.save(...)` calls inside `fn()`
							batch.deactivate();
						}

						unset_context();
					});
			} catch (error) {
				d.reject(error);
				unset_context();
			}

			var batch = /** @type {Batch} */ (current_batch);

			if (should_suspend) {
				var blocking = !boundary.is_pending();

				boundary.update_pending_count(1);
				batch.increment(blocking);

				deferreds.get(batch)?.reject(STALE_REACTION);
				deferreds.delete(batch); // delete to ensure correct order in Map iteration below
				deferreds.set(batch, d);
			}

			/**
			 * @param {any} value
			 * @param {unknown} error
			 */
			const handler = (value, error = undefined) => {

				batch.activate();

				if (error) {
					if (error !== STALE_REACTION) {
						signal.f |= ERROR_VALUE;

						// @ts-expect-error the error is the wrong type, but we don't care
						internal_set(signal, error);
					}
				} else {
					if ((signal.f & ERROR_VALUE) !== 0) {
						signal.f ^= ERROR_VALUE;
					}

					internal_set(signal, value);

					// All prior async derived runs are now stale
					for (const [b, d] of deferreds) {
						deferreds.delete(b);
						if (b === batch) break;
						d.reject(STALE_REACTION);
					}
				}

				if (should_suspend) {
					boundary.update_pending_count(-1);
					batch.decrement(blocking);
				}
			};

			d.promise.then(handler, (e) => handler(null, e || 'unknown'));
		});

		teardown(() => {
			for (const d of deferreds.values()) {
				d.reject(STALE_REACTION);
			}
		});

		return new Promise((fulfil) => {
			/** @param {Promise<V>} p */
			function next(p) {
				function go() {
					if (p === promise) {
						fulfil(signal);
					} else {
						// if the effect re-runs before the initial promise
						// resolves, delay resolution until we have a value
						next(promise);
					}
				}

				p.then(go, go);
			}

			next(promise);
		});
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				// The original parent effect might've been destroyed but the derived
				// is used elsewhere now - do not return the destroyed effect in that case
				return (parent.f & DESTROYED) === 0 ? /** @type {Effect} */ (parent) : null;
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			try {
				derived.f &= ~WAS_MARKED;
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			// in a fork, we don't update the underlying value, just `batch_values`.
			// the underlying value will be updated when the fork is committed.
			// otherwise, the next time we get here after a 'real world' state
			// change, `derived.equals` may incorrectly return `true`
			if (!current_batch?.is_fork) {
				derived.v = value;
			}

			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) {
			return;
		}

		// During time traveling we don't want to reset the status so that
		// traversal of the graph in the other batches still happens
		if (batch_values !== null) {
			// only cache the value if we're in a tracking context, otherwise we won't
			// clear the cache in `mark_reactions` when dependencies are updated
			if (effect_tracking() || current_batch?.is_fork) {
				batch_values.set(derived, value);
			}
		} else {
			var status = (derived.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
			set_signal_status(derived, status);
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Set<any>} */
	let eager_effects = new Set();

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	let eager_effects_deferred = false;

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			// since we are untracking the function inside `$inspect.with` we need to add this check
			// to ensure we error if state is set inside an inspect effect
			(!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 &&
			!current_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			var batch = Batch.ensure();
			batch.capture(source, old_value);

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}

				set_signal_status(source, (source.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			// For debugging, in case you want to know which reactions are being scheduled:
			// log_reactions(source);
			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
				flush_eager_effects();
			}
		}

		return value;
	}

	function flush_eager_effects() {
		eager_effects_deferred = false;
		var prev_is_updating_effect = is_updating_effect;
		set_is_updating_effect(true);

		const inspects = Array.from(eager_effects);

		try {
			for (const effect of inspects) {
				// Mark clean inspect-effects as maybe dirty and then check their dirtiness
				// instead of just updating the effects - this way we avoid overfiring.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (is_dirty(effect)) {
					update_effect(effect);
				}
			}
		} finally {
			set_is_updating_effect(prev_is_updating_effect);
		}

		eager_effects.clear();
	}

	/**
	 * Silently (without using `get`) increment a source
	 * @param {Source<number>} source
	 */
	function increment(source) {
		set(source, source.v + 1);
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			var not_dirty = (flags & DIRTY) === 0;

			// don't set a DIRTY reaction to MAYBE_DIRTY
			if (not_dirty) {
				set_signal_status(reaction, status);
			}

			if ((flags & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (reaction);

				batch_values?.delete(derived);

				if ((flags & WAS_MARKED) === 0) {
					// Only connected deriveds can be reliably unmarked right away
					if (flags & CONNECTED) {
						reaction.f |= WAS_MARKED;
					}

					mark_reactions(derived, MAYBE_DIRTY);
				}
			} else if (not_dirty) {
				if ((flags & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
					eager_block_effects.add(/** @type {Effect} */ (reaction));
				}

				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @import { Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);
		var parent_version = update_version;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			if (update_version === parent_version) {
				return fn();
			}

			// child source is being created after the initial proxy —
			// prevent it from being associated with the current reaction
			var reaction = active_reaction;
			var version = update_version;

			set_active_reaction(null);
			set_update_version(parent_version);

			var result = fn();

			set_active_reaction(reaction);
			set_update_version(version);

			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length));
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value);
						sources.set(prop, s);
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED));
						sources.set(prop, s);
						increment(version);
					}
				} else {
					set(s, UNINITIALIZED);
					increment(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p);

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p);

							return s;
						});

						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create an uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED));
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined));
						set(s, proxy(value));

						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					increment(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return /** @type {TemplateNode | null} */ (first_child_getter.call(node));
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return /** @type {TemplateNode | null} */ (next_sibling_getter.call(node));
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {TemplateNode | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {boolean} [is_text]
	 * @returns {TemplateNode | null}
	 */
	function first_child(node, is_text = false) {
		{
			var first = get_first_child(node);

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {TemplateNode | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/**
	 * Returns `true` if we're updating the current block, for example `condition` in
	 * an `{#if condition}` block just changed. In this case, the branch should be
	 * appended (or removed) at the same time as other updates within the
	 * current `<svelte:boundary>`
	 */
	function should_defer_append() {
		return false;
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null) {
			if (active_reaction === null) {
				effect_orphan();
			}

			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync) {
		var parent = active_effect;

		if (parent !== null && (parent.f & INERT) !== 0) {
			type |= INERT;
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes: null,
			f: type | DIRTY | CONNECTED,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			b: parent && parent.b,
			prev: null,
			teardown: null,
			wv: 0,
			ac: null
		};

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		/** @type {Effect | null} */
		var e = effect;

		// if an effect has already ran and doesn't need to be kept in the tree
		// (because it won't re-run, has no DOM, and has no teardown etc)
		// then we skip it and go to its child (if any)
		if (
			sync &&
			e.deps === null &&
			e.teardown === null &&
			e.nodes === null &&
			e.first === e.last && // either `null`, or a singular child
			(e.f & EFFECT_PRESERVED) === 0
		) {
			e = e.first;
			if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e !== null) {
				e.f |= EFFECT_TRANSPARENT;
			}
		}

		if (e !== null) {
			e.parent = parent;

			if (parent !== null) {
				push_effect(e, parent);
			}

			// if we're in a derived, add the effect there too
			if (
				active_reaction !== null &&
				(active_reaction.f & DERIVED) !== 0 &&
				(type & ROOT_EFFECT) === 0
			) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.effects ??= []).push(e);
			}
		}

		return effect;
	}

	/**
	 * Internal representation of `$effect.tracking()`
	 * @returns {boolean}
	 */
	function effect_tracking() {
		return active_reaction !== null && !untracking;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect();

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var flags = /** @type {Effect} */ (active_effect).f;
		var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;

		if (defer) {
			// Top-level `$effect(...)` in an unmounted component — defer until mount
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push(fn);
		} else {
			// Everything else — create immediately
			return create_user_effect(fn);
		}
	}

	/**
	 * @param {() => void | (() => void)} fn
	 */
	function create_user_effect(fn) {
		return create_effect(EFFECT | USER_EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect();
		return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function async_effect(fn) {
		return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {Array<Promise<void>>} blockers
	 */
	function template_effect(fn, sync = [], async = [], blockers = []) {
		flatten(blockers, sync, async, (values) => {
			create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
		});
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		var effect = create_effect(BLOCK_EFFECT | flags, fn, true);
		return effect;
	}

	/**
	 * @param {(() => void)} fn
	 */
	function branch(fn) {
		return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			const controller = effect.ac;

			if (controller !== null) {
				without_reactive_context(() => {
					controller.abort(STALE_REACTION);
				});
			}

			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes !== null &&
			effect.nodes.end !== null
		) {
			remove_effect_dom(effect.nodes.start, /** @type {TemplateNode} */ (effect.nodes.end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.nodes && effect.nodes.t;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes =
			effect.ac =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : get_next_sibling(node);

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 * @param {boolean} [destroy]
	 */
	function pause_effect(effect, callback, destroy = true) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		var fn = () => {
			if (destroy) destroy_effect(effect);
			if (callback) callback();
		};

		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		var t = effect.nodes && effect.nodes.t;

		if (t !== null) {
			for (const transition of t) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent =
				(child.f & EFFECT_TRANSPARENT) !== 0 ||
				// If this is a branch effect without a block effect parent,
				// it means the parent block effect was pruned. In that case,
				// transparency information was transferred to the branch effect.
				((child.f & BRANCH_EFFECT) !== 0 && (effect.f & BLOCK_EFFECT) !== 0);
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update. we don't use `is_dirty`
		// here because we don't want to eagerly recompute a derived like
		// `{#if foo}{foo.bar()}{/if}` if `foo` is now `undefined
		if ((effect.f & CLEAN) === 0) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		var t = effect.nodes && effect.nodes.t;

		if (t !== null) {
			for (const transition of t) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {DocumentFragment} fragment
	 */
	function move_effect(effect, fragment) {
		if (!effect.nodes) return;

		/** @type {TemplateNode | null} */
		var node = effect.nodes.start;
		var end = effect.nodes.end;

		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : get_next_sibling(node);

			fragment.append(node);
			node = next;
		}
	}

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_updating_effect = false;

	/** @param {boolean} value */
	function set_is_updating_effect(value) {
		is_updating_effect = value;
	}

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | Source[]}
	 */
	let current_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && (true)) {
			if (current_sources === null) {
				current_sources = [value];
			} else {
				current_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	let update_version = read_version;

	/** @param {number} value */
	function set_update_version(value) {
		update_version = value;
	}

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function is_dirty(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if (flags & DERIVED) {
			reaction.f &= ~WAS_MARKED;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;

			if (dependencies !== null) {
				var length = dependencies.length;

				for (var i = 0; i < length; i++) {
					var dependency = dependencies[i];

					if (is_dirty(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			if (
				(flags & CONNECTED) !== 0 &&
				// During time traveling we don't want to reset the status so that
				// traversal of the graph in the other batches still happens
				batch_values === null
			) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		if (current_sources?.includes(signal)) {
			return;
		}

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_sources = current_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var previous_update_version = update_version;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		current_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		update_version = ++read_version;

		if (reaction.ac !== null) {
			without_reactive_context(() => {
				/** @type {AbortController} */ (reaction.ac).abort(STALE_REACTION);
			});

			reaction.ac = null;
		}

		try {
			reaction.f |= REACTION_IS_UPDATING;
			var fn = /** @type {Function} */ (reaction.fn);
			var result = fn();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			if ((reaction.f & ERROR_VALUE) !== 0) {
				reaction.f ^= ERROR_VALUE;
			}

			return result;
		} catch (error) {
			return handle_error(error);
		} finally {
			reaction.f ^= REACTION_IS_UPDATING;
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			current_sources = previous_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
			update_version = previous_update_version;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}

		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected and remove the mark flag, as it cannot be reliably removed otherwise
			if ((dependency.f & CONNECTED) !== 0) {
				dependency.f ^= CONNECTED;
				dependency.f &= ~WAS_MARKED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		try {
			if ((flags & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {

		await Promise.resolve();

		// By calling flushSync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flushSync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			// if we're in a derived that is being read inside an _async_ derived,
			// it's possible that the effect was already destroyed. In this case,
			// we don't add the dependency, because that would create a memory leak
			var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;

			if (!destroyed && !current_sources?.includes(signal)) {
				var deps = active_reaction.deps;

				if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
					// we're in the effect init/update cycle
					if (signal.rv < read_version) {
						signal.rv = read_version;

						// If the signal is accessing the same dependencies in the same
						// order as it did last time, increment `skipped_deps`
						// rather than updating `new_deps`, which creates GC cost
						if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
							skipped_deps++;
						} else if (new_deps === null) {
							new_deps = [signal];
						} else if (!new_deps.includes(signal)) {
							new_deps.push(signal);
						}
					}
				} else {
					// we're adding a dependency outside the init/update cycle
					// (i.e. after an `await`)
					(active_reaction.deps ??= []).push(signal);

					var reactions = signal.reactions;

					if (reactions === null) {
						signal.reactions = [active_reaction];
					} else if (!reactions.includes(active_reaction)) {
						reactions.push(active_reaction);
					}
				}
			}
		}

		if (is_destroying_effect) {
			if (old_values.has(signal)) {
				return old_values.get(signal);
			}

			if (is_derived) {
				var derived = /** @type {Derived} */ (signal);

				var value = derived.v;

				// if the derived is dirty and has reactions, or depends on the values that just changed, re-execute
				// (a derived can be maybe_dirty due to the effect destroy removing its last reaction)
				if (
					((derived.f & CLEAN) === 0 && derived.reactions !== null) ||
					depends_on_old_values(derived)
				) {
					value = execute_derived(derived);
				}

				old_values.set(derived, value);

				return value;
			}
		} else if (
			is_derived &&
			(!batch_values?.has(signal) || (current_batch?.is_fork && !effect_tracking()))
		) {
			derived = /** @type {Derived} */ (signal);

			if (is_dirty(derived)) {
				update_derived(derived);
			}

			if (is_updating_effect && effect_tracking() && (derived.f & CONNECTED) === 0) {
				reconnect(derived);
			}
		}

		if (batch_values?.has(signal)) {
			return batch_values.get(signal);
		}

		if ((signal.f & ERROR_VALUE) !== 0) {
			throw signal.v;
		}

		return signal.v;
	}

	/**
	 * (Re)connect a disconnected derived, so that it is notified
	 * of changes in `mark_reactions`
	 * @param {Derived} derived
	 */
	function reconnect(derived) {
		if (derived.deps === null) return;

		derived.f ^= CONNECTED;

		for (const dep of derived.deps) {
			(dep.reactions ??= []).push(derived);

			if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
				reconnect(/** @type {Derived} */ (dep));
			}
		}
	}

	/** @param {Derived} derived */
	function depends_on_old_values(derived) {
		if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst
		if (derived.deps === null) return false;

		for (const dep of derived.deps) {
			if (old_values.has(dep)) {
				return true;
			}

			if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		if (
			dom === document.body ||
			// @ts-ignore
			dom === window ||
			// @ts-ignore
			dom === document ||
			// Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
			dom instanceof HTMLMediaElement
		) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	// used to store the reference to the currently propagated event
	// to prevent garbage collection between microtasks in Firefox
	// If the event object is GCed too early, the expando __root property
	// set on the event object is lost, causing the event delegation
	// to process the event twice
	let last_propagated_event = null;

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		last_propagated_event = event;

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// the `last_propagated_event === event` check is redundant, but
		// without it the variable will be DCE'd and things will
		// fail mysteriously in Firefox
		// @ts-expect-error is added below
		var handled_at = last_propagated_event === event && event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						delegated.call(current_target, event);
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, EffectNodes, TemplateNode } from '#client' */
	/** @import { TemplateStructure } from './types' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes === null) {
			effect.nodes = { start, end, a: null, t: null };
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {TemplateNode} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, EffectNodes, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @typedef {{ effect: Effect, fragment: DocumentFragment }} Branch
	 */

	/**
	 * @template Key
	 */
	class BranchManager {
		/** @type {TemplateNode} */
		anchor;

		/** @type {Map<Batch, Key>} */
		#batches = new Map();

		/**
		 * Map of keys to effects that are currently rendered in the DOM.
		 * These effects are visible and actively part of the document tree.
		 * Example:
		 * ```
		 * {#if condition}
		 * 	foo
		 * {:else}
		 * 	bar
		 * {/if}
		 * ```
		 * Can result in the entries `true->Effect` and `false->Effect`
		 * @type {Map<Key, Effect>}
		 */
		#onscreen = new Map();

		/**
		 * Similar to #onscreen with respect to the keys, but contains branches that are not yet
		 * in the DOM, because their insertion is deferred.
		 * @type {Map<Key, Branch>}
		 */
		#offscreen = new Map();

		/**
		 * Keys of effects that are currently outroing
		 * @type {Set<Key>}
		 */
		#outroing = new Set();

		/**
		 * Whether to pause (i.e. outro) on change, or destroy immediately.
		 * This is necessary for `<svelte:element>`
		 */
		#transition = true;

		/**
		 * @param {TemplateNode} anchor
		 * @param {boolean} transition
		 */
		constructor(anchor, transition = true) {
			this.anchor = anchor;
			this.#transition = transition;
		}

		#commit = () => {
			var batch = /** @type {Batch} */ (current_batch);

			// if this batch was made obsolete, bail
			if (!this.#batches.has(batch)) return;

			var key = /** @type {Key} */ (this.#batches.get(batch));

			var onscreen = this.#onscreen.get(key);

			if (onscreen) {
				// effect is already in the DOM — abort any current outro
				resume_effect(onscreen);
				this.#outroing.delete(key);
			} else {
				// effect is currently offscreen. put it in the DOM
				var offscreen = this.#offscreen.get(key);

				if (offscreen) {
					this.#onscreen.set(key, offscreen.effect);
					this.#offscreen.delete(key);

					// remove the anchor...
					/** @type {TemplateNode} */ (offscreen.fragment.lastChild).remove();

					// ...and append the fragment
					this.anchor.before(offscreen.fragment);
					onscreen = offscreen.effect;
				}
			}

			for (const [b, k] of this.#batches) {
				this.#batches.delete(b);

				if (b === batch) {
					// keep values for newer batches
					break;
				}

				const offscreen = this.#offscreen.get(k);

				if (offscreen) {
					// for older batches, destroy offscreen effects
					// as they will never be committed
					destroy_effect(offscreen.effect);
					this.#offscreen.delete(k);
				}
			}

			// outro/destroy all onscreen effects...
			for (const [k, effect] of this.#onscreen) {
				// ...except the one that was just committed
				//    or those that are already outroing (else the transition is aborted and the effect destroyed right away)
				if (k === key || this.#outroing.has(k)) continue;

				const on_destroy = () => {
					const keys = Array.from(this.#batches.values());

					if (keys.includes(k)) {
						// keep the effect offscreen, as another batch will need it
						var fragment = document.createDocumentFragment();
						move_effect(effect, fragment);

						fragment.append(create_text()); // TODO can we avoid this?

						this.#offscreen.set(k, { effect, fragment });
					} else {
						destroy_effect(effect);
					}

					this.#outroing.delete(k);
					this.#onscreen.delete(k);
				};

				if (this.#transition || !onscreen) {
					this.#outroing.add(k);
					pause_effect(effect, on_destroy, false);
				} else {
					on_destroy();
				}
			}
		};

		/**
		 * @param {Batch} batch
		 */
		#discard = (batch) => {
			this.#batches.delete(batch);

			const keys = Array.from(this.#batches.values());

			for (const [k, branch] of this.#offscreen) {
				if (!keys.includes(k)) {
					destroy_effect(branch.effect);
					this.#offscreen.delete(k);
				}
			}
		};

		/**
		 *
		 * @param {any} key
		 * @param {null | ((target: TemplateNode) => void)} fn
		 */
		ensure(key, fn) {
			var batch = /** @type {Batch} */ (current_batch);
			var defer = should_defer_append();

			if (fn && !this.#onscreen.has(key) && !this.#offscreen.has(key)) {
				if (defer) {
					var fragment = document.createDocumentFragment();
					var target = create_text();

					fragment.append(target);

					this.#offscreen.set(key, {
						effect: branch(() => fn(target)),
						fragment
					});
				} else {
					this.#onscreen.set(
						key,
						branch(() => fn(this.anchor))
					);
				}
			}

			this.#batches.set(batch, key);

			if (defer) {
				for (const [k, effect] of this.#onscreen) {
					if (k === key) {
						batch.skipped_effects.delete(effect);
					} else {
						batch.skipped_effects.add(effect);
					}
				}

				for (const [k, branch] of this.#offscreen) {
					if (k === key) {
						batch.skipped_effects.delete(branch.effect);
					} else {
						batch.skipped_effects.add(branch.effect);
					}
				}

				batch.oncommit(this.#commit);
				batch.ondiscard(this.#discard);
			} else {

				this.#commit();
			}
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		onMount(() => () => untrack(fn));
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/** @import { TemplateNode } from '#client' */

	// TODO reinstate https://github.com/sveltejs/svelte/pull/15250

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {

		var branches = new BranchManager(node);
		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		/**
		 * @param {boolean} condition,
		 * @param {null | ((anchor: Node) => void)} fn
		 */
		function update_branch(condition, fn) {

			branches.ensure(condition, fn);
		}

		block(() => {
			var has_branch = false;

			fn((fn, flag = true) => {
				has_branch = true;
				update_branch(flag, fn);
			});

			if (!has_branch) {
				update_branch(false, null);
			}
		}, flags);
	}

	/** @import { EachItem, EachOutroGroup, EachState, Effect, EffectNodes, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	// When making substantive changes to this file, validate them with the each block stress test:
	// https://svelte.dev/playground/1972b2cf46564476ad8c8c6405b23b7b
	// This test also exists in this repo, as `packages/svelte/tests/manual/each-stress-test`

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index$1(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {Effect[]} to_destroy
	 * @param {null | Node} controlled_anchor
	 */
	function pause_effects(state, to_destroy, controlled_anchor) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = to_destroy.length;

		/** @type {EachOutroGroup} */
		var group;
		var remaining = to_destroy.length;

		for (var i = 0; i < length; i++) {
			let effect = to_destroy[i];

			pause_effect(
				effect,
				() => {
					if (group) {
						group.pending.delete(effect);
						group.done.add(effect);

						if (group.pending.size === 0) {
							var groups = /** @type {Set<EachOutroGroup>} */ (state.outrogroups);

							destroy_effects(array_from(group.done));
							groups.delete(group);

							if (groups.size === 0) {
								state.outrogroups = null;
							}
						}
					} else {
						remaining -= 1;
					}
				},
				false
			);
		}

		if (remaining === 0) {
			// If we're in a controlled each block (i.e. the block is the only child of an
			// element), and we are removing all items, _and_ there are no out transitions,
			// we can use the fast path — emptying the element and replacing the anchor
			var fast_path = transitions.length === 0 && controlled_anchor !== null;

			if (fast_path) {
				var anchor = /** @type {Element} */ (controlled_anchor);
				var parent_node = /** @type {Element} */ (anchor.parentNode);

				clear_text_content(parent_node);
				parent_node.append(anchor);

				state.items.clear();
			}

			destroy_effects(to_destroy, !fast_path);
		} else {
			group = {
				pending: new Set(to_destroy),
				done: new Set()
			};

			(state.outrogroups ??= new Set()).add(group);
		}
	}

	/**
	 * @param {Effect[]} to_destroy
	 * @param {boolean} remove_dom
	 */
	function destroy_effects(to_destroy, remove_dom = true) {
		// TODO only destroy effects if no pending batch needs them. otherwise,
		// just re-add the `EFFECT_OFFSCREEN` flag
		for (var i = 0; i < to_destroy.length; i++) {
			destroy_effect(to_destroy[i], remove_dom);
		}
	}

	/** @type {TemplateNode} */
	var offscreen_anchor;

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {Map<any, EachItem>} */
		var items = new Map();

		{
			var parent_node = /** @type {Element} */ (node);

			anchor = parent_node.appendChild(create_text());
		}

		/** @type {Effect | null} */
		var fallback = null;

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		/** @type {V[]} */
		var array;

		var first_run = true;

		function commit() {
			state.fallback = fallback;
			reconcile(state, array, anchor, flags, get_key);

			if (fallback !== null) {
				if (array.length === 0) {
					if ((fallback.f & EFFECT_OFFSCREEN) === 0) {
						resume_effect(fallback);
					} else {
						fallback.f ^= EFFECT_OFFSCREEN;
						move(fallback, null, anchor);
					}
				} else {
					pause_effect(fallback, () => {
						// TODO only null out if no pending batch needs it,
						// otherwise re-add `fallback.fragment` and move the
						// effect into it
						fallback = null;
					});
				}
			}
		}

		var effect = block(() => {
			array = /** @type {V[]} */ (get(each_array));
			var length = array.length;

			var keys = new Set();
			var batch = /** @type {Batch} */ (current_batch);
			var defer = should_defer_append();

			for (var index = 0; index < length; index += 1) {

				var value = array[index];
				var key = get_key(value, index);

				var item = first_run ? null : items.get(key);

				if (item) {
					// update before reconciliation, to trigger any async updates
					if (item.v) internal_set(item.v, value);
					if (item.i) internal_set(item.i, index);

					if (defer) {
						batch.skipped_effects.delete(item.e);
					}
				} else {
					item = create_item(
						items,
						first_run ? anchor : (offscreen_anchor ??= create_text()),
						value,
						key,
						index,
						render_fn,
						flags,
						get_collection
					);

					if (!first_run) {
						item.e.f |= EFFECT_OFFSCREEN;
					}

					items.set(key, item);
				}

				keys.add(key);
			}

			if (length === 0 && fallback_fn && !fallback) {
				if (first_run) {
					fallback = branch(() => fallback_fn(anchor));
				} else {
					fallback = branch(() => fallback_fn((offscreen_anchor ??= create_text())));
					fallback.f |= EFFECT_OFFSCREEN;
				}
			}

			if (!first_run) {
				if (defer) {
					for (const [key, item] of items) {
						if (!keys.has(key)) {
							batch.skipped_effects.add(item.e);
						}
					}

					batch.oncommit(commit);
					batch.ondiscard(() => {
						// TODO presumably we need to do something here?
					});
				} else {
					commit();
				}
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get(each_array);
		});

		/** @type {EachState} */
		var state = { effect, items, outrogroups: null, fallback };

		first_run = false;
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {EachState} state
	 * @param {Array<V>} array
	 * @param {Element | Comment | Text} anchor
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @returns {void}
	 */
	function reconcile(state, array, anchor, flags, get_key) {

		var length = array.length;
		var items = state.items;
		var current = state.effect.first;

		/** @type {undefined | Set<Effect>} */
		var seen;

		/** @type {Effect | null} */
		var prev = null;

		/** @type {Effect[]} */
		var matched = [];

		/** @type {Effect[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {Effect | undefined} */
		var effect;

		/** @type {number} */
		var i;

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);

			effect = /** @type {EachItem} */ (items.get(key)).e;

			if (state.outrogroups !== null) {
				for (const group of state.outrogroups) {
					group.pending.delete(effect);
					group.done.delete(effect);
				}
			}

			if ((effect.f & EFFECT_OFFSCREEN) !== 0) {
				effect.f ^= EFFECT_OFFSCREEN;

				if (effect === current) {
					move(effect, null, anchor);
				} else {
					var next = prev ? prev.next : current;

					if (effect === state.effect.last) {
						state.effect.last = effect.prev;
					}

					if (effect.prev) effect.prev.next = effect.next;
					if (effect.next) effect.next.prev = effect.prev;
					link(state, prev, effect);
					link(state, effect, next);

					move(effect, next, anchor);
					prev = effect;

					matched = [];
					stashed = [];

					current = prev.next;
					continue;
				}
			}

			if ((effect.f & INERT) !== 0) {
				resume_effect(effect);
			}

			if (effect !== current) {
				if (seen !== undefined && seen.has(effect)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(effect);
						move(effect, current, anchor);

						link(state, effect.prev, effect.next);
						link(state, effect, prev === null ? state.effect.first : prev.next);
						link(state, prev, effect);

						prev = effect;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current !== effect) {
					(seen ??= new Set()).add(current);
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}
			}

			if ((effect.f & EFFECT_OFFSCREEN) === 0) {
				matched.push(effect);
			}

			prev = effect;
			current = effect.next;
		}

		if (state.outrogroups !== null) {
			for (const group of state.outrogroups) {
				if (group.pending.size === 0) {
					destroy_effects(array_from(group.done));
					state.outrogroups?.delete(group);
				}
			}

			if (state.outrogroups.size === 0) {
				state.outrogroups = null;
			}
		}

		if (current !== null || seen !== undefined) {
			/** @type {Effect[]} */
			var to_destroy = [];

			if (seen !== undefined) {
				for (effect of seen) {
					if ((effect.f & INERT) === 0) {
						to_destroy.push(effect);
					}
				}
			}

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.f & INERT) === 0 && current !== state.fallback) {
					to_destroy.push(current);
				}

				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = length === 0 ? anchor : null;

				pause_effects(state, to_destroy, controlled_anchor);
			}
		}
	}

	/**
	 * @template V
	 * @param {Map<any, EachItem>} items
	 * @param {Node} anchor
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(items, anchor, value, key, index, render_fn, flags, get_collection) {
		var v =
			(flags & EACH_ITEM_REACTIVE) !== 0
				? (flags & EACH_ITEM_IMMUTABLE) === 0
					? mutable_source(value, false, false)
					: source(value)
				: null;

		var i = (flags & EACH_INDEX_REACTIVE) !== 0 ? source(index) : null;

		return {
			v,
			i,
			e: branch(() => {
				render_fn(anchor, v ?? value, i ?? index, get_collection);

				return () => {
					items.delete(key);
				};
			})
		};
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(effect, next, anchor) {
		if (!effect.nodes) return;

		var node = effect.nodes.start;
		var end = effect.nodes.end;

		var dest =
			next && (next.f & EFFECT_OFFSCREEN) === 0
				? /** @type {EffectNodes} */ (next.nodes).start
				: anchor;

		while (node !== null) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);

			if (node === end) {
				return;
			}

			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {Effect | null} prev
	 * @param {Effect | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.effect.first = next;
		} else {
			prev.next = next;
		}

		if (next === null) {
			state.effect.last = prev;
		} else {
			next.prev = prev;
		}
	}

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		{
			classname = classname ? classname + ' ' + hash : hash;
		}

		return classname === '' ? null : classname;
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash);

			{
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else {
					dom.className = next_class_name;
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		}

		return next_classes;
	}

	/** @import { Batch } from '../../../reactivity/batch.js' */

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var batches = new WeakSet();

		listen_to_event_and_reset_event(input, 'input', async (is_reset) => {

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}

			// Because `{#each ...}` blocks work by updating sources inside the flush,
			// we need to wait a tick before checking to see if we should forcibly
			// update the input and reset the selection state
			await tick();

			// Respect any validation in accessors
			if (value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;
				var length = input.value.length;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					var new_length = input.value.length;
					// If cursor was at end and new input is longer, move cursor to new end
					if (start === end && end === length && new_length > length) {
						input.selectionStart = new_length;
						input.selectionEnd = new_length;
					} else {
						input.selectionStart = start;
						input.selectionEnd = Math.min(end, new_length);
					}
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}
		}

		render_effect(() => {

			var value = get();

			if (input === document.activeElement) {
				// we need both, because in non-async mode, render effects run before previous_batch is set
				var batch = /** @type {Batch} */ (previous_batch ?? current_batch);

				// Never rewrite the contents of a focused input. We can get here if, for example,
				// an update is deferred because of async work depending on the input:
				//
				// <input bind:value={query}>
				// <p>{await find(query)}</p>
				if (batches.has(batch)) {
					return;
				}
			}

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get(signal);
		}

		props();
	}

	var config = {
	    name: "convective-tracker",
	    version: "1.0.4",
	    description: "Convective Tracker",
	    author: "Andrew Lemos",
	    windyPlugin: {
	        version: "1.0.4",
	        left: 400,
	        top: 100,
	        width: 400,
	        height: 600,
	        icon: "🌪️"
	    }
	};

	var root_2 = from_html(`<p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Aceleração:</strong> <span class="unit-note svelte-1k5fwm8"> </span></p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Status:</strong> <span class="significant svelte-1k5fwm8">SIGNIFICANTE</span></p>`, 1);
	var root_3 = from_html(`<p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Aceleração:</strong> </p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Status:</strong> <span class="insignificant svelte-1k5fwm8">insignificante</span></p>`, 1);
	var root_1 = from_html(`<div class="calculation-result svelte-1k5fwm8"><h4 class="svelte-1k5fwm8">Resultados dos Cálculos:</h4> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Velocidade atual:</strong> <span class="unit-note svelte-1k5fwm8"> </span></p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Direção atual:</strong> </p> <!> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Distância total:</strong> </p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Tempo total:</strong> </p> <p class="calculation-method svelte-1k5fwm8"> </p></div>`);
	var root_5 = from_html(`<p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Chegada estimada:</strong> </p>`);
	var root_6 = from_html(`<p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Velocidade final estimada:</strong> <span class="unit-note svelte-1k5fwm8"> </span></p>`);
	var root_4 = from_html(`<div><h4 class="svelte-1k5fwm8">Posição Projetada:</h4> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Latitude:</strong> </p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Longitude:</strong> </p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Distância:</strong> </p> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Intervalo:</strong> </p> <!> <!> <p class="svelte-1k5fwm8"><strong class="svelte-1k5fwm8">Método:</strong> </p></div>`);
	var root_8 = from_html(`<div class="point-metrics svelte-1k5fwm8"><span class="svelte-1k5fwm8"> </span> <span class="svelte-1k5fwm8"> </span></div>`);
	var root_7 = from_html(`<div class="point-item svelte-1k5fwm8"><div class="point-header svelte-1k5fwm8"><span class="point-number svelte-1k5fwm8"></span> <span class="point-time svelte-1k5fwm8"> </span></div> <div class="point-coords svelte-1k5fwm8"><span class="svelte-1k5fwm8"> </span> <span class="svelte-1k5fwm8"> </span></div> <div class="point-time-info svelte-1k5fwm8"><small class="svelte-1k5fwm8"> </small></div> <!></div>`);
	var root_9 = from_html(`<div class="no-points svelte-1k5fwm8">Nenhum ponto marcado ainda. Ative o modo de marcação e clique no mapa.</div>`);
	var root = from_html(`<div class="plugin__mobile-header svelte-1k5fwm8">Convective Tracker</div> <section class="plugin__content svelte-1k5fwm8"><div class="plugin-logo-container svelte-1k5fwm8"><div class="logo-title svelte-1k5fwm8">Convective Tracker</div></div> <div class="plugin__title plugin__title--chevron-back svelte-1k5fwm8" style="display: none;">Convective Tracker</div> <div class="tracker-controls svelte-1k5fwm8"><div class="control-section svelte-1k5fwm8"><h3 class="svelte-1k5fwm8">Controle de Tempo</h3> <div class="time-control-section svelte-1k5fwm8"><div class="manual-time-input svelte-1k5fwm8"><div class="time-input-row svelte-1k5fwm8"><div class="input-group svelte-1k5fwm8"><label for="manualHours" class="svelte-1k5fwm8">Hora:</label> <input type="number" id="manualHours" min="0" max="23" placeholder="HH" class="svelte-1k5fwm8"/></div> <div class="input-group svelte-1k5fwm8"><label for="manualMinutes" class="svelte-1k5fwm8">Minutos:</label> <input type="number" id="manualMinutes" min="0" max="59" placeholder="MM" class="svelte-1k5fwm8"/></div> <button class="btn btn-secondary svelte-1k5fwm8">Agora</button></div> <div class="time-display-info svelte-1k5fwm8"><small class="svelte-1k5fwm8"> </small></div></div></div></div> <div class="control-section svelte-1k5fwm8"><h3 class="svelte-1k5fwm8">Marcador de Pontos</h3> <div class="button-group svelte-1k5fwm8"><button class="btn btn-primary svelte-1k5fwm8"> </button> <button class="btn btn-warning svelte-1k5fwm8">Reiniciar Tracking</button> <button class="btn btn-secondary svelte-1k5fwm8">Limpar Tudo</button></div> <div class="info-display svelte-1k5fwm8"><p class="svelte-1k5fwm8"> </p> <p class="svelte-1k5fwm8">Modo: <span> </span></p> <!></div></div> <div class="control-section svelte-1k5fwm8"><h3 class="svelte-1k5fwm8">Projeção de Trajetória</h3> <div class="projection-controls svelte-1k5fwm8"><div class="time-input svelte-1k5fwm8"><label for="projectionTime" class="svelte-1k5fwm8">Tempo de projeção (minutos):</label> <div class="time-slider-container svelte-1k5fwm8"><input type="range" id="projectionTime" min="1" max="240" step="1" class="svelte-1k5fwm8"/> <div class="slider-ticks svelte-1k5fwm8"><span class="svelte-1k5fwm8">1</span><span class="svelte-1k5fwm8">30</span><span class="svelte-1k5fwm8">60</span><span class="svelte-1k5fwm8">90</span><span class="svelte-1k5fwm8">240</span></div></div> <div class="time-display svelte-1k5fwm8"><span class="svelte-1k5fwm8"> </span> <span class="unit-note svelte-1k5fwm8"> </span></div></div> <div class="projection-options svelte-1k5fwm8"><label class="checkbox-label svelte-1k5fwm8"><input type="checkbox" class="svelte-1k5fwm8"/> <span class="svelte-1k5fwm8">Usar movimento uniforme (ignorar aceleração)</span></label> <label class="checkbox-label svelte-1k5fwm8"><input type="checkbox" class="svelte-1k5fwm8"/> <span class="svelte-1k5fwm8">Manter linhas de projeção</span></label></div> <div class="button-group svelte-1k5fwm8"><button class="btn btn-primary svelte-1k5fwm8">Projetar Trajetória</button> <button class="btn btn-secondary svelte-1k5fwm8">Limpar Projeção</button></div></div> <!></div> <div class="control-section svelte-1k5fwm8"><h3 class="svelte-1k5fwm8">Histórico de Pontos</h3> <div class="points-list svelte-1k5fwm8"></div></div></div> <div class="plugin-footer svelte-1k5fwm8">Desenvolvido por Andrew Lemos</div></section>`, 1);

	function Plugin($$anchor, $$props) {
		push($$props, false);

		// IMPORTAÇÕES DO WINDY
		const { name } = config;

		// timestamp em milissegundos
		// timestamp formatado
		// velocidade deste segmento
		// direção deste segmento
		// velocidade mais recente
		// velocidade média
		// direção mais recente
		// direção média
		// tempo do último segmento em segundos
		// inclinação da direção em graus
		const EARTH_RADIUS_KM = 6371;

		const EARTH_RADIUS_M = 6371000;
		const SIGNIFICANT_ACCELERATION = 0.001;

		// Variáveis principais
		let points = mutable_source([]);

		let trackingMode = mutable_source(false);
		let leafletMarkers = [];
		let leafletLines = [];
		let projectionLine = null;
		let lastCalculation = mutable_source(null);
		let projectionTime = mutable_source(60);
		let projectedPosition = mutable_source(null);
		let useUniformMotion = mutable_source(false);
		let keepProjectionLines = mutable_source(true);

		// Variáveis para horário manual SIMPLIFICADO
		let manualHours = mutable_source(14);

		let manualMinutes = mutable_source(0);

		let manualDate = mutable_source(new Date().toISOString().split('T')[0]); 

		// Função para definir hora atual
		function setCurrentTime() {
			const now = new Date();

			set(manualHours, now.getHours());
			set(manualMinutes, now.getMinutes());
			set(manualDate, now.toISOString().split('T')[0]);
		}

		// Obter timestamp 
		function getManualTimestamp() {
			try {
				let hours = get(manualHours);
				let minutes = get(manualMinutes);
				const dateStr = get(manualDate); // Obter data do usuário
		
				if (isNaN(hours) || hours < 0 || hours > 23) hours = 14;
				if (isNaN(minutes) || minutes < 0 || minutes > 59) minutes = 0;
		
				// Se já temos pontos, verificar mudança de dia
				const currentPoints = get(points);
				if (currentPoints.length > 0) {
					const lastPointTime = currentPoints[currentPoints.length - 1].time;
					const lastDate = new Date(lastPointTime);
					
					// Se a hora manual for MENOR que a hora do último ponto,
					// provavelmente mudou de dia
					if (hours < lastDate.getHours() || 
					   (hours === lastDate.getHours() && minutes < lastDate.getMinutes())) {
						// Usar o dia seguinte ao último ponto
						lastDate.setDate(lastDate.getDate() + 1);
						lastDate.setHours(hours, minutes, 0, 0);
						console.log('📅 Mudança de dia detectada, usando dia seguinte');
						return lastDate.getTime();
					}
					
					// Mesmo dia, apenas ajustar hora
					lastDate.setHours(hours, minutes, 0, 0);
					return lastDate.getTime();
				} else {
					// Primeiro ponto: usar data especificada pelo usuário
					const dateParts = dateStr.split('-');
					const year = parseInt(dateParts[0]);
					const month = parseInt(dateParts[1]) - 1;
					const day = parseInt(dateParts[2]);
					
					const date = new Date(year, month, day, hours, minutes, 0, 0);
					return date.getTime();
				}
			} catch(error) {
				console.error('❌ Erro ao criar timestamp:', error);
				return Date.now();
			}
		}

		// Mostrar próximo horário que será usado
		function getNextPointTimeDisplay() {
			try {
				const timestamp = getManualTimestamp();

				return formatDateTime(timestamp);
			} catch(error) {
				return 'Horário inválido';
			}
		}

		// Formatar hora
		function formatTime(timestamp) {
			try {
				const date = new Date(timestamp);

				if (isNaN(date.getTime())) return '--:--:--';

				return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
			} catch(error) {
				return '--:--:--';
			}
		}

		// Formatar data e hora
		function formatDateTime(timestamp) {
			try {
				const date = new Date(timestamp);

				if (isNaN(date.getTime())) return 'Data/hora inválida';

				return date.toLocaleString([], {
					year: 'numeric',
					month: '2-digit',
					day: '2-digit',
					hour: '2-digit',
					minute: '2-digit'
				});
			} catch(error) {
				return 'Data/hora inválida';
			}
		}

		// FUNÇÕES DE CÁLCULO
		function calculateDistanceMeters(point1, point2) {
			const φ1 = point1.lat * Math.PI / 180;
			const φ2 = point2.lat * Math.PI / 180;
			const Δφ = (point2.lat - point1.lat) * Math.PI / 180;
			const Δλ = (point2.lon - point1.lon) * Math.PI / 180;
			const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

			return EARTH_RADIUS_M * c;
		}

		function calculateDistanceKm(point1, point2) {
			return calculateDistanceMeters(point1, point2) / 1000;
		}

		function calculateVelocity(point1, point2) {
			const distanceM = calculateDistanceMeters(point1, point2);
			const timeDiffS = (point2.time - point1.time) / 1000;
			
			if (timeDiffS <= 0) {
				console.log(`⚠️  Tempo inválido para cálculo: ${timeDiffS}s`);
				return 0;
			}
			
			// CORREÇÃO: Usar Math.abs() para garantir POSITIVO
			const velocity = Math.abs(distanceM / timeDiffS);
			
			console.log(`📊 Velocidade calculada: ${velocity.toFixed(2)} m/s (${(velocity * 3.6).toFixed(1)} km/h)`);
			
			return velocity; // SEMPRE positivo
		}

		function calculateAcceleration(points) {
			if (points.length < 3) return { acceleration: 0, hasSignificant: false };
		
			const lastPoints = points.slice(-3);
			const v1 = Math.abs(calculateVelocity(lastPoints[0], lastPoints[1])); // CORREÇÃO: Math.abs
			const v2 = Math.abs(calculateVelocity(lastPoints[1], lastPoints[2])); // CORREÇÃO: Math.abs
			const Δt1 = (lastPoints[1].time - lastPoints[0].time) / 1000;
			const Δt2 = (lastPoints[2].time - lastPoints[1].time) / 1000;
		
			if (Δt1 <= 0 || Δt2 <= 0) return { acceleration: 0, hasSignificant: false };
		
			const Δt = Δt2;
			const acceleration = Math.abs(v2 - v1) / Δt; // CORREÇÃO: Math.abs
			const velocityChangePercent = Math.abs((v2 - v1) / Math.max(v1, 0.001)) * 100;
			const isSignificantByPercent = velocityChangePercent > 10;
			const isSignificantByAbsolute = Math.abs(acceleration) > SIGNIFICANT_ACCELERATION;
			const hasSignificant = isSignificantByAbsolute || isSignificantByPercent;

			console.log(`📊 ACELERAÇÃO DETALHADA:`);
			console.log(`   v1 = ${v1.toFixed(2)} m/s (${(v1 * 3.6).toFixed(1)} km/h)`);
			console.log(`   v2 = ${v2.toFixed(2)} m/s (${(v2 * 3.6).toFixed(1)} km/h)`);
			console.log(`   Δv = ${(v2 - v1).toFixed(2)} m/s`);
			console.log(`   Δt = ${Δt.toFixed(0)} s`);
			console.log(`   a = (v2 - v1) / Δt = ${(v2 - v1).toFixed(2)} / ${Δt.toFixed(0)}`);
			console.log(`   a = ${acceleration.toFixed(4)} m/s²`);
			console.log(`   Mudança percentual: ${velocityChangePercent.toFixed(1)}%`);
			console.log(`   Limite absoluto: ${SIGNIFICANT_ACCELERATION} m/s²`);
			console.log(`   Significativo por absoluto? ${isSignificantByAbsolute}`);
			console.log(`   Significativo por percentual? ${isSignificantByPercent}`);
			console.log(`   ACELERAÇÃO SIGNIFICATIVA? ${hasSignificant ? 'SIM ✅' : 'NÃO ❌'}`);

			return { acceleration, hasSignificant };
		}

		function calculateDirection(point1, point2) {
			const φ1 = point1.lat * Math.PI / 180;
			const φ2 = point2.lat * Math.PI / 180;
			const λ1 = point1.lon * Math.PI / 180;
			const λ2 = point2.lon * Math.PI / 180;
			const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
			const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
			const θ = Math.atan2(y, x);

			return (θ * 180 / Math.PI + 360) % 360;
		}

		function calculateAverageDirection(directions) {
			if (directions.length === 0) return 0;

			let x = 0;
			let y = 0;

			directions.forEach((dir) => {
				const rad = dir * Math.PI / 180;

				x += Math.cos(rad);
				y += Math.sin(rad);
			});

			const avgRad = Math.atan2(y, x);

			return (avgRad * 180 / Math.PI + 360) % 360;
		}

		function estimateNextDirection(currentDirection, previousDirection) {
			const diff = currentDirection - previousDirection;
			let normalizedDiff = diff;

			while (normalizedDiff > 180) normalizedDiff -= 360;
			while (normalizedDiff < -180) normalizedDiff += 360;

			const extrapolationFactor = 1.5;
			let nextDirection = currentDirection + normalizedDiff * extrapolationFactor;

			nextDirection = (nextDirection + 360) % 360;
			console.log(`📐 ESTIMATIVA DE DIREÇÃO:`);
			console.log(`   Anterior: ${previousDirection.toFixed(0)}°`);
			console.log(`   Atual: ${currentDirection.toFixed(0)}°`);
			console.log(`   Diferença: ${normalizedDiff.toFixed(0)}°`);
			console.log(`   Fator de extrapolação: ${extrapolationFactor}`);
			console.log(`   Próximo estimado: ${nextDirection.toFixed(0)}°`);

			return nextDirection;
		}

		function toggleTrackingMode() {
			set(trackingMode, !get(trackingMode));
			console.log('Modo tracking:', get(trackingMode) ? 'ATIVO' : 'INATIVO');

			if (get(trackingMode)) {
				console.log('✅ Pronto para marcar pontos! Clique no mapa.');
			}
		}

		function resetTracking() {
			console.log('🔄 REINICIANDO TRACKING COMPLETAMENTE...');
			
			// 1. Limpar pontos
			set(points, []);
			
			// 2. Desativar tracking
			set(trackingMode, false);
			
			// 3. Limpar cálculos
			set(lastCalculation, null);
			set(projectedPosition, null);
			
			// 4. Remover marcadores do mapa
			const mapObj = getMap();
			if (mapObj) {
				// Remover marcadores de pontos
				leafletMarkers.forEach(marker => {
					try {
						if (marker && mapObj.hasLayer(marker)) {
							mapObj.removeLayer(marker);
						}
					} catch (e) {
						console.warn('⚠️  Erro ao remover marcador:', e);
					}
				});
				
				// Remover linhas
				leafletLines.forEach(line => {
					try {
						if (line && mapObj.hasLayer(line)) {
							mapObj.removeLayer(line);
						}
					} catch (e) {
						console.warn('⚠️  Erro ao remover linha:', e);
					}
				});
				
				// Remover linha de projeção
				if (projectionLine && mapObj.hasLayer(projectionLine)) {
					try {
						mapObj.removeLayer(projectionLine);
						projectionLine = null;
					} catch (e) {
						console.warn('⚠️  Erro ao remover projeção:', e);
					}
				}
			}
			
			// 5. Limpar arrays
			leafletMarkers = [];
			leafletLines = [];
			
			// 6. Resetar horário
			const now = new Date();
			set(manualHours, now.getHours());
			set(manualMinutes, now.getMinutes());
			set(manualDate, now.toISOString().split('T')[0]); // Resetar data
			
			console.log('✅ TRACKING REINICIADO! Pontos: 0, Tracking: INATIVO');
		}
		function addWindyMarker(lat, lon, pointNumber, timestamp) {
			try {
				const marker = L.marker([lat, lon], {
					icon: map.markers.pulsatingIcon,
					title: `Ponto ${pointNumber} - ${timestamp}`
				}).addTo(map.map);

				marker.bindTooltip(`Ponto ${pointNumber}<br>${timestamp}`, { permanent: false, direction: 'top' });

				marker.bindPopup(`
                <div style="text-align: center; padding: 5px;">
                    <strong>Ponto ${pointNumber}</strong><br>
                    ${timestamp}<br>
                    Lat: ${lat.toFixed(4)}°<br>
                    Lon: ${lon.toFixed(4)}°
                </div>
            `);

				leafletMarkers.push(marker);
				console.log(`📍 Marcador ${pointNumber} adicionado`);

				return marker;
			} catch(error) {
				console.error('❌ Erro ao adicionar marcador:', error);

				return null;
			}
		}

		function handleMapClick(lat, lon) {
			if (!get(trackingMode)) {
				console.log('⚠️ Modo tracking inativo. Ative primeiro clicando em "Iniciar Marcação"');

				return;
			}

			try {
				const currentTimestamp = getManualTimestamp();
				const timestampDisplay = formatTime(currentTimestamp);

				const newPoint = {
					lat,
					lon,
					time: currentTimestamp,
					timestamp: timestampDisplay
				};

				if (get(points).length > 0) {
					const lastPoint = get(points)[get(points).length - 1];

					newPoint.distanceFromPrev = calculateDistanceKm(lastPoint, newPoint);
					newPoint.timeFromPrev = currentTimestamp - lastPoint.time;

					if (newPoint.timeFromPrev > 0) {
						newPoint.velocity = calculateVelocity(lastPoint, newPoint);
						newPoint.direction = calculateDirection(lastPoint, newPoint);
						console.log(`📊 Δ Tempo: ${(newPoint.timeFromPrev / 1000 / 60).toFixed(1)} min`);
						console.log(`📊 Velocidade: ${newPoint.velocity?.toFixed(1)} m/s (${(newPoint.velocity * 3.6).toFixed(1)} km/h)`);
						console.log(`📊 Direção: ${newPoint.direction?.toFixed(1)}°`);
					}
				}

				set(points, [...get(points), newPoint]);

				console.log(`✅ Ponto ${get(points).length} marcado:`, {
					lat: lat.toFixed(4),
					lon: lon.toFixed(4),
					time: formatDateTime(currentTimestamp)
				});

				addWindyMarker(lat, lon, get(points).length, timestampDisplay);

				if (get(points).length >= 2) {
					drawTrajectoryLine();
					calculateTrajectory();
				}
			} catch(error) {
				console.error('❌ Erro ao marcar ponto:', error);
				alert('Erro ao marcar ponto. Verifique os dados.');
			}
		}

		function drawTrajectoryLine() {
			if (get(points).length < 2) return;

			leafletLines.forEach((line) => {
				if (map.map && line) map.map.removeLayer(line);
			});

			leafletLines = [];

			const latLngs = get(points).map((p) => [p.lat, p.lon]);
			const line = L.polyline(latLngs, { color: '#ff0000', weight: 3, opacity: 0.7, dashArray: null }).addTo(map.map);

			leafletLines.push(line);
		}

		function calculateTrajectory() {
			if (get(points).length < 2) {
				console.log('Precisa de pelo menos 2 pontos para calcular trajetória');

				return;
			}

			const velocities = [];
			const directions = [];
			let totalDistanceM = 0;
			let totalTimeS = 0;
			let lastSegmentTime = 0;

			for (let i = 0; i < get(points).length - 1; i++) {
				const velocity = calculateVelocity(get(points)[i], get(points)[i + 1]);

				velocities.push(velocity);
				directions.push(calculateDirection(get(points)[i], get(points)[i + 1]));
				totalDistanceM += calculateDistanceMeters(get(points)[i], get(points)[i + 1]);

				const segmentTime = (get(points)[i + 1].time - get(points)[i].time) / 1000;

				totalTimeS += segmentTime;

				if (i === get(points).length - 2) {
					lastSegmentTime = segmentTime;
				}
			}

			if (totalTimeS <= 0) {
				console.error('❌ Tempo total inválido para cálculo.');
				set(lastCalculation, null);

				return;
			}

			const avgVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
			const currentVelocity = velocities.length > 0 ? velocities[velocities.length - 1] : avgVelocity;
			const { acceleration, hasSignificant } = calculateAcceleration(get(points));
			const avgDirection = calculateAverageDirection(directions);
			const currentDirection = directions.length > 0 ? directions[directions.length - 1] : avgDirection;
			let directionAngle = currentDirection;

			if (directions.length >= 2) {
				directionAngle = estimateNextDirection(directions[directions.length - 1], directions[directions.length - 2]);
			}

			let shouldUseUniformMotion = false;

			if (get(useUniformMotion)) {
				shouldUseUniformMotion = true;
				console.log('⚙️ Usando MRU (usuário escolheu movimento uniforme)');
			} else if (hasSignificant) {
				shouldUseUniformMotion = false;
				console.log('⚙️ Usando MRUV (aceleração significativa detectada)');
			} else {
				shouldUseUniformMotion = true;
				console.log('⚙️ Usando MRU (aceleração insignificante)');
			}

			let estimatedInstantVelocity = currentVelocity;

			if (hasSignificant && !shouldUseUniformMotion && lastSegmentTime > 0) {
				estimatedInstantVelocity = currentVelocity + acceleration * lastSegmentTime;
				console.log(`📊 VELOCIDADE INSTANTÂNEA COM ACELERAÇÃO:`);
				console.log(`   v0 = ${currentVelocity.toFixed(2)} m/s`);
				console.log(`   a = ${acceleration.toFixed(4)} m/s²`);
				console.log(`   t = ${lastSegmentTime.toFixed(0)} s`);
				console.log(`   v = ${currentVelocity.toFixed(2)} + ${acceleration.toFixed(4)} * ${lastSegmentTime.toFixed(0)}`);
				console.log(`   v = ${estimatedInstantVelocity.toFixed(2)} m/s`);
			}

			set(lastCalculation, {
				currentVelocity: estimatedInstantVelocity,
				avgVelocity,
				acceleration,
				currentDirection: directionAngle,
				avgDirection,
				hasSignificantAcceleration: hasSignificant,
				useUniformMotion: shouldUseUniformMotion,
				points: [...get(points)],
				totalDistance: totalDistanceM / 1000,
				totalTime: totalTimeS,
				lastSegmentTime,
				directionAngle
			});

			console.log(('=').repeat(60));
			console.log('📊 RESUMO DA TRAJETÓRIA CALCULADA:');
			console.log(('=').repeat(60));
			console.log(`   Velocidade atual: ${estimatedInstantVelocity.toFixed(1)} m/s (${(estimatedInstantVelocity * 3.6).toFixed(1)} km/h)`);
			console.log(`   Velocidade média: ${avgVelocity.toFixed(1)} m/s`);
			console.log(`   Direção atual: ${currentDirection.toFixed(0)}°`);
			console.log(`   Direção estimada: ${directionAngle.toFixed(0)}°`);
			console.log(`   Aceleração: ${acceleration.toFixed(4)} m/s²`);
			console.log(`   Status aceleração: ${hasSignificant ? 'SIGNIFICANTE ✅' : 'insignificante'}`);

			console.log(`   Método selecionado: ${shouldUseUniformMotion
			? 'MRU (Movimento Uniforme)'
			: 'MRUV (Movimento Uniformemente Variado)'}`);

			console.log(`   Distância total: ${(totalDistanceM / 1000).toFixed(1)} km`);
			console.log(`   Tempo total: ${(totalTimeS / 60).toFixed(1)} min`);
			console.log(('=').repeat(60));
		}

		function calculateDestinationPoint(lat, lon, bearing, distanceKm) {
			const R = EARTH_RADIUS_KM;
			const distanceRad = distanceKm / R;
			const bearingRad = bearing * Math.PI / 180;
			const lat1 = lat * Math.PI / 180;
			const lon1 = lon * Math.PI / 180;
			const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distanceRad) + Math.cos(lat1) * Math.sin(distanceRad) * Math.cos(bearingRad));
			const lon2 = lon1 + Math.atan2(Math.sin(bearingRad) * Math.sin(distanceRad) * Math.cos(lat1), Math.cos(distanceRad) - Math.sin(lat1) * Math.sin(lat2));

			return {
				lat: lat2 * 180 / Math.PI,
				lon: (lon2 * 180 / Math.PI + 540) % 360 - 180
			};
		}

		function projectTrajectory() {
		    if (!get(lastCalculation) || get(points).length < 2) {
		        console.log('Não há cálculo disponível para projetar');
		        return;
		    }
		
		    try {
		        const lastPoint = get(points)[get(points).length - 1];
		        const timeInSeconds = get(projectionTime) * 60;
		        let projectedDistanceM;
		        let finalVelocityMps;
		        let useAcceleration = false;
		
		        console.log(('=').repeat(60));
		        console.log('🚀 INICIANDO PROJEÇÃO DE TRAJETÓRIA');
		        console.log(('=').repeat(60));
		        console.log(`   Tempo de projeção: ${timeInSeconds} s (${get(projectionTime)} min)`);
		        console.log(`   Velocidade atual: ${Math.abs(get(lastCalculation).currentVelocity).toFixed(2)} m/s (${(Math.abs(get(lastCalculation).currentVelocity) * 3.6).toFixed(1)} km/h)`);
		        console.log(`   Aceleração: ${Math.abs(get(lastCalculation).acceleration).toFixed(4)} m/s²`);
		        console.log(`   Direção: ${get(lastCalculation).currentDirection.toFixed(0)}°`);
		        console.log(`   Aceleração significativa? ${get(lastCalculation).hasSignificantAcceleration ? 'SIM ✅' : 'NÃO ❌'}`);
		        console.log(`   Config. usuário (usar MRU): ${get(useUniformMotion) ? 'SIM' : 'NÃO'}`);
		        console.log(`   Método calculado: ${get(lastCalculation).useUniformMotion ? 'MRU' : 'MRUV'}`);
		
		        let forceUseAcceleration = false;
		
		        if (get(lastCalculation).hasSignificantAcceleration && !get(useUniformMotion)) {
		            forceUseAcceleration = true;
		            console.log('⚡ FORÇANDO USO DE MRUV (aceleração significativa detectada)');
		        }
		
		        // Usar valores absolutos para cálculos
		        const absVelocity = Math.abs(get(lastCalculation).currentVelocity);
		        const absAcceleration = Math.abs(get(lastCalculation).acceleration);
		
		        if (get(lastCalculation).useUniformMotion && !forceUseAcceleration) {
		            projectedDistanceM = absVelocity * timeInSeconds;
		            finalVelocityMps = absVelocity;
		            useAcceleration = false;
		            console.log('\n📏 PROJEÇÃO MRU (Movimento Uniforme):');
		            console.log(`   Fórmula: s = |v| * t`);
		            console.log(`   |v| = ${absVelocity.toFixed(2)} m/s`);
		            console.log(`   t = ${timeInSeconds} s`);
		            console.log(`   s = ${absVelocity.toFixed(2)} * ${timeInSeconds}`);
		            console.log(`   s = ${projectedDistanceM.toFixed(0)} m`);
		        } else {
		            const v0 = absVelocity;
		            const a = absAcceleration;
		            const part1 = v0 * timeInSeconds;
		            const part2 = 0.5 * a * timeInSeconds * timeInSeconds;
		
		            projectedDistanceM = part1 + part2;
		            finalVelocityMps = v0 + a * timeInSeconds;
		            useAcceleration = true;
		            console.log('\n📏 PROJEÇÃO MRUV (Movimento Uniformemente Variado):');
		            console.log(`   Fórmula: s = |v0|*t + 0.5*|a|*t²`);
		            console.log(`   |v0| = ${v0.toFixed(2)} m/s`);
		            console.log(`   |a| = ${a.toFixed(4)} m/s²`);
		            console.log(`   t = ${timeInSeconds} s`);
		            console.log(`   |v0|*t = ${v0.toFixed(2)} * ${timeInSeconds} = ${part1.toFixed(0)} m`);
		            console.log(`   0.5*|a|*t² = 0.5 * ${a.toFixed(4)} * ${timeInSeconds}² = ${part2.toFixed(0)} m`);
		            console.log(`   s = ${part1.toFixed(0)} + ${part2.toFixed(0)} = ${projectedDistanceM.toFixed(0)} m`);
		            console.log(`\n📏 Velocidade final (|v| = |v0| + |a|*t):`);
		            console.log(`   |v| = ${v0.toFixed(2)} + ${a.toFixed(4)} * ${timeInSeconds}`);
		            console.log(`   |v| = ${v0.toFixed(2)} + ${(a * timeInSeconds).toFixed(2)}`);
		            console.log(`   |v| = ${finalVelocityMps.toFixed(2)} m/s`);
		        }
		
		        const MAX_DISTANCE_M = 10000 * 1000;
		        const MAX_VELOCITY_MPS = 500;
		
		        // Garantir que a distância projetada nunca seja negativa (usar valor absoluto)
		        projectedDistanceM = Math.abs(projectedDistanceM);
		        
		        // Garantir que a velocidade final nunca seja negativa (usar valor absoluto)
		        finalVelocityMps = Math.abs(finalVelocityMps);
		
		        // Se valores forem muito pequenos, manter como estão (não setar a 0)
		        if (projectedDistanceM > MAX_DISTANCE_M) {
		            console.warn(`⚠️ Distância muito alta: ${projectedDistanceM.toFixed(0)} m, limitando para ${MAX_DISTANCE_M} m`);
		            projectedDistanceM = MAX_DISTANCE_M;
		        }
		
		        if (finalVelocityMps > MAX_VELOCITY_MPS) {
		            console.warn(`⚠️ Velocidade final muito alta: ${finalVelocityMps.toFixed(1)} m/s, limitando para ${MAX_VELOCITY_MPS} m/s`);
		            finalVelocityMps = MAX_VELOCITY_MPS;
		        }
		
		        const projectedDistanceKm = projectedDistanceM / 1000;
		
		        console.log(`\n📏 DISTÂNCIA FINAL PROJETADA: ${projectedDistanceKm.toFixed(1)} km`);
		
		        const bearing = get(lastCalculation).currentDirection;
		        const destination = calculateDestinationPoint(lastPoint.lat, lastPoint.lon, bearing, projectedDistanceKm);
		
		        if (destination.lat < -90 || destination.lat > 90 || destination.lon < -180 || destination.lon > 180) {
		            console.warn(`⚠️ Coordenadas fora dos limites: Lat=${destination.lat.toFixed(4)}, Lon=${destination.lon.toFixed(4)}`);
		
		            if (destination.lat < -90) destination.lat = -90;
		            if (destination.lat > 90) destination.lat = 90;
		            if (destination.lon < -180) destination.lon = -180 + 360;
		            if (destination.lon > 180) destination.lon = 180 - 360;
		        }
		
		        const arrivalTime = new Date(lastPoint.time + get(projectionTime) * 60 * 1000);
		        const arrivalTimeStr = arrivalTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
		
		        set(projectedPosition, {
		            lat: destination.lat,
		            lon: destination.lon,
		            distance: projectedDistanceKm,
		            estimatedArrival: arrivalTimeStr,
		            useAcceleration,
		            finalVelocity: finalVelocityMps
		        });
		
		        clearProjection();
		
		        const destMarker = L.marker([destination.lat, destination.lon], {
		            icon: L.divIcon({
		                html: useAcceleration
		                    ? '<div style="background: #ff00ff; color: #fff; width: 28px; height: 28px; border-radius: 50%; border: 3px solid #fff; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; box-shadow: 0 0 10px #ff00ff;">🎯</div>'
		                    : '<div style="background: #00ff00; color: #000; width: 28px; height: 28px; border-radius: 50%; border: 3px solid #000; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; box-shadow: 0 0 10px #00ff00;">🎯</div>',
		
		                iconSize: [28, 28],
		                className: 'destination-marker'
		            }),
		
		            title: `Destino em ${get(projectionTime)} minutos`
		        }).addTo(map.map);
		
		        destMarker.bindTooltip(`Destino em ${get(projectionTime)} min<br>` + 
		            `Distância: ${projectedDistanceKm.toFixed(1)} km<br>` + 
		            `Velocidade final: ${finalVelocityMps.toFixed(1)} m/s (${(finalVelocityMps * 3.6).toFixed(1)} km/h)<br>` + 
		            `Chegada: ${arrivalTimeStr}<br>` + 
		            `Método: ${useAcceleration ? 'MRUV (com aceleração)' : 'MRU (sem aceleração)'}`, 
		            { permanent: false, direction: 'top' });
		        leafletMarkers.push(destMarker);
		
		        projectionLine = L.polyline(
		            [
		                [lastPoint.lat, lastPoint.lon],
		                [destination.lat, destination.lon]
		            ],
		            {
		                color: useAcceleration ? '#ff00ff' : '#00ff00',
		                weight: 3,
		                opacity: 0.8,
		                dashArray: useAcceleration ? '10, 10' : null,
		                lineCap: 'round'
		            }
		        ).addTo(map.map);
		
		        console.log('\n🎯 RESULTADO DA PROJEÇÃO:');
		        console.log(('=').repeat(60));
		        console.log(`   Posição: ${destination.lat.toFixed(4)}°, ${destination.lon.toFixed(4)}°`);
		        console.log(`   Distância: ${projectedDistanceKm.toFixed(1)} km`);
		        console.log(`   Velocidade final: ${finalVelocityMps.toFixed(1)} m/s (${(finalVelocityMps * 3.6).toFixed(1)} km/h)`);
		        console.log(`   Chegada: ${arrivalTimeStr}`);
		        console.log(`   Método: ${useAcceleration ? 'MRUV (Movimento Uniformemente Variado)' : 'MRU (Movimento Uniforme)'}`);
		        console.log(('=').repeat(60));
		    } catch(error) {
		        console.error('❌ ERRO AO PROJETAR TRAJETÓRIA:', error);
		        alert('Erro ao projetar trajetória: ' + error.message);
		    }
		}

		function clearProjection() {
			if (projectionLine && map.map && map.map.hasLayer(projectionLine)) {
				map.map.removeLayer(projectionLine);
				projectionLine = null;
			}

			const mapObj = getMap();

			if (mapObj) {
				const markersToRemove = [];

				leafletMarkers.forEach((marker, index) => {
					if (marker.options.icon?.options?.className === 'destination-marker') {
						if (mapObj.hasLayer(marker)) {
							mapObj.removeLayer(marker);
							markersToRemove.push(index);
						}
					}
				});

				markersToRemove.reverse().forEach((index) => {
					leafletMarkers.splice(index, 1);
				});
			}

			set(projectedPosition, null);
			console.log('🧹 Projeção limpa');
		}

		function clearAll() {
			console.log('🧹 INICIANDO LIMPEZA TOTAL...');
			clearProjection();
			set(points, []);
			set(lastCalculation, null);
			set(projectedPosition, null);

			const mapObj = getMap();

			if (mapObj) {
				leafletMarkers.forEach((marker) => {
					if (mapObj.hasLayer(marker)) {
						mapObj.removeLayer(marker);
					}
				});

				leafletLines.forEach((line) => {
					if (mapObj.hasLayer(line)) {
						mapObj.removeLayer(line);
					}
				});
			}

			leafletMarkers = [];
			leafletLines = [];
			set(trackingMode, false);
			console.log('✅ TODOS OS DADOS FORAM LIMPOS COMPLETAMENTE');
		}

		function getMap() {
			return map.map;
		}

		onMount(() => {
			console.log('🚀 Plugin Convective Tracker iniciando...');
			console.log('🔧 Nome do plugin:', name);
			console.log('⚙️ CONFIGURAÇÃO DO SISTEMA:');
			console.log('   - Sensibilidade da aceleração:', SIGNIFICANT_ACCELERATION, 'm/s²');
			console.log('   - Detecta aceleração por valor absoluto OU mudança percentual > 10%');
			console.log('   - MRU padrão: DESATIVADO (teste MRUV primeiro)');
			console.log('   - Botão "Limpar Projeção": SEMPRE ATIVO');
			setCurrentTime();

			if (singleclick.singleclick && typeof singleclick.singleclick.on === 'function') {
				try {
					console.log('🎯 Configurando singleclick listener...');

					singleclick.singleclick.on(name, (latLon) => {
						console.log('🗺️ Clique recebido:', latLon);
						handleMapClick(latLon.lat, latLon.lon);
					});

					console.log('✅ Listener configurado!');
				} catch(error) {
					console.error('❌ Erro ao configurar singleclick:', error);
				}
			}

			console.log('\n📝 INSTRUÇÕES PARA TESTE:');
			console.log('   1. Desmarque "Usar movimento uniforme" para testar MRUV');
			console.log('   2. Marque 3+ pontos com intervalos regulares');
			console.log('   3. Veja no console se aceleração é detectada como SIGNIFICANTE');
			console.log('   4. Projete trajetória e compare MRU vs MRUV');
			console.log('   5. Use "Limpar Projeção" a qualquer momento');
			console.log('   6. Use "Limpar Tudo" para reiniciar completamente');
			console.log('\n🎯 Plugin Convective Tracker carregado e pronto!');
		});

		onDestroy(() => {
			console.log('🔚 Plugin sendo destruído...');

			if (singleclick.singleclick && typeof singleclick.singleclick.off === 'function') {
				try {
					singleclick.singleclick.off(name);
					console.log('✅ Listener singleclick removido');
				} catch(error) {
					console.error('❌ Erro ao remover listener:', error);
				}
			}

			clearAll();
		});

		init();

		var fragment = root();
		var section = sibling(first_child(fragment), 2);
		var div = sibling(child(section), 4);
		var div_1 = child(div);
		var div_2 = sibling(child(div_1), 2);
		var div_3 = child(div_2);
		var div_4 = child(div_3);
		var div_5 = child(div_4);
		var input = sibling(child(div_5), 2);

		var div_6 = sibling(div_5, 2);
		var input_1 = sibling(child(div_6), 2);

		var button = sibling(div_6, 2);

		var div_7 = sibling(div_4, 2);
		var small = child(div_7);
		var text = child(small);

		var div_8 = sibling(div_1, 2);
		var div_9 = sibling(child(div_8), 2);
		var button_1 = child(div_9);
		var text_1 = child(button_1);

		var button_2 = sibling(button_1, 2);
		var button_3 = sibling(button_2, 2);

		var div_10 = sibling(div_9, 2);
		var p_1 = child(div_10);
		var text_2 = child(p_1);

		var p_2 = sibling(p_1, 2);
		var span = sibling(child(p_2));
		var text_3 = child(span);

		var node = sibling(p_2, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_11 = root_1();
				var p_3 = sibling(child(div_11), 2);
				var text_4 = sibling(child(p_3));
				var span_1 = sibling(text_4);
				var text_5 = child(span_1);

				var p_4 = sibling(p_3, 2);
				var text_6 = sibling(child(p_4));

				var node_1 = sibling(p_4, 2);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = root_2();
						var p_5 = first_child(fragment_1);
						var text_7 = sibling(child(p_5));
						var span_2 = sibling(text_7);
						var text_8 = child(span_2);

						template_effect(
							($0, $1) => {
								set_text(text_7, ` ${$0 ?? ''} m/s² `);
								set_text(text_8, `(${$1 ?? ''} km/h por hora)`);
							},
							[
								() => get(lastCalculation).acceleration.toFixed(4),
								() => (get(lastCalculation).acceleration * 12960).toFixed(1)
							]
						);

						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var fragment_2 = root_3();
						var p_6 = first_child(fragment_2);
						var text_9 = sibling(child(p_6));
						template_effect(($0) => set_text(text_9, ` ${$0 ?? ''} m/s²`), [() => get(lastCalculation).acceleration.toFixed(4)]);
						append($$anchor, fragment_2);
					};

					if_block(node_1, ($$render) => {
						if (get(lastCalculation).hasSignificantAcceleration) $$render(consequent); else $$render(alternate, false);
					});
				}

				var p_7 = sibling(node_1, 2);
				var text_10 = sibling(child(p_7));

				var p_8 = sibling(p_7, 2);
				var text_11 = sibling(child(p_8));

				var p_9 = sibling(p_8, 2);
				var text_12 = child(p_9);

				template_effect(
					($0, $1, $2, $3, $4) => {
						set_text(text_4, ` ${$0 ?? ''} m/s `);
						set_text(text_5, `(${$1 ?? ''} km/h)`);
						set_text(text_6, ` ${$2 ?? ''}°`);
						set_text(text_10, ` ${$3 ?? ''} km`);
						set_text(text_11, ` ${$4 ?? ''} min`);

						set_text(text_12, `Método: ${get(lastCalculation).useUniformMotion
						? 'Movimento Uniforme'
						: 'Movimento Uniformemente Variado'}`);
					},
					[
						() => get(lastCalculation).currentVelocity.toFixed(1),
						() => (get(lastCalculation).currentVelocity * 3.6).toFixed(1),
						() => get(lastCalculation).currentDirection.toFixed(0),
						() => get(lastCalculation).totalDistance.toFixed(1),
						() => (get(lastCalculation).totalTime / 60).toFixed(1)
					]
				);

				append($$anchor, div_11);
			};

			if_block(node, ($$render) => {
				if (get(lastCalculation)) $$render(consequent_1);
			});
		}

		var div_12 = sibling(div_8, 2);
		var div_13 = sibling(child(div_12), 2);
		var div_14 = child(div_13);
		var div_15 = sibling(child(div_14), 2);
		var input_2 = child(div_15);

		var div_16 = sibling(div_15, 2);
		var span_3 = child(div_16);
		var text_13 = child(span_3);

		var span_4 = sibling(span_3, 2);
		var text_14 = child(span_4);

		var div_17 = sibling(div_14, 2);
		var label = child(div_17);
		var input_3 = child(label);

		var label_1 = sibling(label, 2);
		var input_4 = child(label_1);

		var div_18 = sibling(div_17, 2);
		var button_4 = child(div_18);
		var button_5 = sibling(button_4, 2);

		var node_2 = sibling(div_13, 2);

		{
			var consequent_4 = ($$anchor) => {
				var div_19 = root_4();
				var p_10 = sibling(child(div_19), 2);
				var text_15 = sibling(child(p_10));

				var p_11 = sibling(p_10, 2);
				var text_16 = sibling(child(p_11));

				var p_12 = sibling(p_11, 2);
				var text_17 = sibling(child(p_12));

				var p_13 = sibling(p_12, 2);
				var text_18 = sibling(child(p_13));

				var node_3 = sibling(p_13, 2);

				{
					var consequent_2 = ($$anchor) => {
						var p_14 = root_5();
						var text_19 = sibling(child(p_14));
						template_effect(() => set_text(text_19, ` ${get(projectedPosition).estimatedArrival ?? ''}`));
						append($$anchor, p_14);
					};

					if_block(node_3, ($$render) => {
						if (get(projectedPosition).estimatedArrival) $$render(consequent_2);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_3 = ($$anchor) => {
						var p_15 = root_6();
						var text_20 = sibling(child(p_15));
						var span_5 = sibling(text_20);
						var text_21 = child(span_5);

						template_effect(
							($0, $1) => {
								set_text(text_20, ` ${$0 ?? ''} m/s `);
								set_text(text_21, `(${$1 ?? ''} km/h)`);
							},
							[
								() => get(projectedPosition).finalVelocity.toFixed(1),
								() => (get(projectedPosition).finalVelocity * 3.6).toFixed(1)
							]
						);

						append($$anchor, p_15);
					};

					if_block(node_4, ($$render) => {
						if (get(projectedPosition).finalVelocity) $$render(consequent_3);
					});
				}

				var p_16 = sibling(node_4, 2);
				var text_22 = sibling(child(p_16));

				template_effect(
					($0, $1, $2) => {
						set_class(div_19, 1, `projection-result ${get(projectedPosition).useAcceleration ? 'accelerated' : 'uniform'}`, 'svelte-1k5fwm8');
						set_text(text_15, ` ${$0 ?? ''}°`);
						set_text(text_16, ` ${$1 ?? ''}°`);
						set_text(text_17, ` ${$2 ?? ''} km`);
						set_text(text_18, ` ${get(projectionTime) ?? ''} minutos`);

						set_text(text_22, ` ${get(projectedPosition).useAcceleration
						? 'Movimento Uniformemente Variado (com aceleração)'
						: 'Movimento Uniforme (sem aceleração)'}`);
					},
					[
						() => get(projectedPosition).lat.toFixed(4),
						() => get(projectedPosition).lon.toFixed(4),
						() => get(projectedPosition).distance.toFixed(1)
					]
				);

				append($$anchor, div_19);
			};

			if_block(node_2, ($$render) => {
				if (get(projectedPosition)) $$render(consequent_4);
			});
		}

		var div_20 = sibling(div_12, 2);
		var div_21 = sibling(child(div_20), 2);

		each(
			div_21,
			5,
			() => get(points),
			index$1,
			($$anchor, point, i) => {
				var div_22 = root_7();
				var div_23 = child(div_22);
				var span_6 = child(div_23);

				span_6.textContent = `Ponto #${i + 1}`;

				var span_7 = sibling(span_6, 2);
				var text_23 = child(span_7);

				var div_24 = sibling(div_23, 2);
				var span_8 = child(div_24);
				var text_24 = child(span_8);

				var span_9 = sibling(span_8, 2);
				var text_25 = child(span_9);

				var div_25 = sibling(div_24, 2);
				var small_1 = child(div_25);
				var text_26 = child(small_1);

				var node_5 = sibling(div_25, 2);

				{
					var consequent_5 = ($$anchor) => {
						var div_26 = root_8();
						var span_10 = child(div_26);
						var text_27 = child(span_10);

						var span_11 = sibling(span_10, 2);
						var text_28 = child(span_11);

						template_effect(
							($0, $1) => {
								set_text(text_27, `Distância: ${$0 ?? ''} km`);
								set_text(text_28, `Intervalo: ${$1 ?? ''} min`);
							},
							[
								() => get(point).distanceFromPrev ? get(point).distanceFromPrev.toFixed(1) : 'N/A',

								() => get(point).timeFromPrev
									? (get(point).timeFromPrev / 1000 / 60).toFixed(1)
									: 'N/A'
							]
						);

						append($$anchor, div_26);
					};

					if_block(node_5, ($$render) => {
						if (i > 0) $$render(consequent_5);
					});
				}

				template_effect(
					($0, $1, $2, $3) => {
						set_text(text_23, $0);
						set_text(text_24, `Lat: ${$1 ?? ''}°`);
						set_text(text_25, `Lon: ${$2 ?? ''}°`);
						set_text(text_26, $3);
					},
					[
						() => formatTime(get(point).time),
						() => get(point).lat.toFixed(4),
						() => get(point).lon.toFixed(4),
						() => formatDateTime(get(point).time)
					]
				);

				append($$anchor, div_22);
			},
			($$anchor) => {
				var div_27 = root_9();

				append($$anchor, div_27);
			}
		);

		template_effect(
			($0, $1) => {
				set_text(text, `Próximo ponto: ${$0 ?? ''}`);
				set_text(text_1, get(trackingMode) ? 'Parar Marcação' : 'Iniciar Marcação');
				button_2.disabled = get(points).length === 0;
				button_3.disabled = get(points).length === 0;
				set_text(text_2, `Pontos marcados: ${get(points).length ?? ''}`);
				set_class(span, 1, `status-indicator ${get(trackingMode) ? 'active' : 'inactive'}`, 'svelte-1k5fwm8');
				set_text(text_3, get(trackingMode) ? 'ATIVO' : 'INATIVO');
				set_text(text_13, `${get(projectionTime) ?? ''} minutos`);
				set_text(text_14, `(${$1 ?? ''} horas)`);
				button_4.disabled = !get(lastCalculation) || get(points).length < 2;
			},
			[
				getNextPointTimeDisplay,
				() => (get(projectionTime) / 60).toFixed(1)
			]
		);

		bind_value(input, () => get(manualHours), ($$value) => set(manualHours, $$value));
		bind_value(input_1, () => get(manualMinutes), ($$value) => set(manualMinutes, $$value));
		event('click', button, setCurrentTime);
		event('click', button_1, toggleTrackingMode);
		event('click', button_2, resetTracking);
		event('click', button_3, clearAll);
		bind_value(input_2, () => get(projectionTime), ($$value) => set(projectionTime, $$value));
		bind_checked(input_3, () => get(useUniformMotion), ($$value) => set(useUniformMotion, $$value));
		bind_checked(input_4, () => get(keepProjectionLines), ($$value) => set(keepProjectionLines, $$value));
		event('click', button_4, projectTrajectory);
		event('click', button_5, clearProjection);
		append($$anchor, fragment);
		pop();
	}

	// src/index.js

	// Ou exportação padrão
	var index = { Plugin, config };

	exports.Plugin = Plugin;
	exports.config = config;
	exports.default = index;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({}, windySingleclick, windyMap);
